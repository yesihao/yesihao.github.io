{"meta":{"title":"Shane In Tech Life","subtitle":"as above","description":"Shane's blog","author":"Shane Ye","url":"http://shenye.me","root":"/"},"pages":[],"posts":[{"title":"Azure Functions - 配置开发环境","slug":"Azure Function Part I","date":"2020-03-29T12:55:10.000Z","updated":"2020-04-07T15:17:16.390Z","comments":true,"path":"2020/03/29/Azure Function Part I/","link":"","permalink":"http://shenye.me/2020/03/29/Azure Function Part I/","excerpt":"","text":"前言说Azure functions之前先来说说Serverless。Serverless是最近很火的一个概念，它是一种基于互联网的技术架构理念，应用逻辑并非全部在服务端实现，而是采用FAAS（Function as a Service）架构，通过功能组合来实现应用程序逻辑。应用业务逻辑将基于FAAS架构形成独立为多个相互独立功能组件，并以API服务的形式向外提供服务；很多公司都在自己的云平台推出了FAAS，比如Amazon Lambda，Azure Function，Google Cloud Functions，阿里云Function Compute等。 微软的Azure functions是基于Azure的无服务器计算服务，可以快速的帮助用户构建一个基于事件驱动的应用架构。用户无需关心服务器的部署运营，只需专注于核心的逻辑，既可以发布上线。费用按照实际调用次数与时长计费，自动缩放，仅在运行函数时为计算资源付费。更棒的是Azure Functions支持C#，Python，Javascript，TypeScript，F#和Java，本文带大家快速看在本地搭建Javascript开发环境开发Azure Functions。 环境安裝可以使用Visual Studio Code和Visual Studio开发，本文将会使用的VS Code。 首先在扩展市场中搜索Azure functions，你也可以直接安裝Azure App Service，这样你就拥有所有相关扩展服务，也可以仅安裝Azure Functions。 接著，我们要安裝 Azure Function Core Tools，在命令行安装： 12345678910#via npmnpm i -g azure-functions-core-tools --unsafe-perm true#Linuxwget -q https://packages.microsoft.com/config/ubuntu/19.04/packages-microsoft-prod.debsudo dpkg -i packages-microsoft-prod.deb#Macbrew tap azure/functionsbrew install azure-functions-core-tools 或者我们可以点击Debug | Run, VS Code会自动提示安装Azure Function Core Tools，确定后自动执行上方命令。 安裝成功之后，我们可以在命令行输入 func 来检查是否安装成功。 出现 *闪电（ 就说明安装成功了！ ##预告 下一篇博文将会讲到 如何快速部署Azure Function","categories":[],"tags":[{"name":"Serverless, Azure, Azure Function","slug":"Serverless-Azure-Azure-Function","permalink":"http://shenye.me/tags/Serverless-Azure-Azure-Function/"}]},{"title":"Javascript - 排序排序的小技巧","slug":"Javascript - 排序排序的小技巧","date":"2020-02-28T11:34:40.000Z","updated":"2020-04-01T04:57:55.188Z","comments":true,"path":"2020/02/28/Javascript - 排序排序的小技巧/","link":"","permalink":"http://shenye.me/2020/02/28/Javascript - 排序排序的小技巧/","excerpt":"","text":"普通数组:1let fruits = [`bananas`, `Apples`, `Oranges`]; 很简单，一行搞定： 1fruits.sort(); 但是要注意数组中不同字符串的大小写不一致… 大写的字符会被排在小写字符之前😂所以还有其他的步骤： 1234567let fruits = [`bananas`, `Apples`, `Oranges`];fruits.sort((a, b) =&gt; &#123; return a.toLowerCase().localeCompare(b.toLowerCase());&#125;)console.log(fruits);// [\"Apples\", \"bananas\", \"Oranges\"] 对象数组（按对象键值排序）对对象数组的排序会变得很稍微更复杂一些。经常我们会在处理JSON API的时候遇到。 1234567891011let fruits = [ &#123; fruit: `Bananas` &#125;, &#123; fruit: `apples` &#125;, &#123; fruit: `Oranges` &#125;]; 我们可以为此写一个排序函数，但是更进一步我们需要一个更通用的方法把需要排序的键以参数的形式传进去 1234567891011121314const propComparator = (propName) =&gt; (a, b) =&gt; a[propName].toLowerCase() == b[propName].toLowerCase() ? 0 : a[propName].toLowerCase() &lt; b[propName].toLowerCase() ? -1 : 1So now we can use it to sort:fruits.sort(propComparator(`fruit`));console.log(fruits);/*[ &#123;fruit: \"apples\"&#125;, &#123;fruit: \"Bananas\"&#125;, &#123;fruit: \"Oranges\"&#125;]*/ 普通对象如果我们有个对象是这样的： 12345let fruits = &#123; Bananas: true, apples: false, Oranges: true&#125;; 我们依然可以将那些键小写化，然后我们先排序键的数组，然后用排序好的键数组建一个新对象 123456789101112131415let sortedFruits = &#123;&#125;;Object.keys(fruits).sort((a, b) =&gt; &#123; return a.toLowerCase().localeCompare(b.toLowerCase());&#125;).forEach(function(key) &#123; sortedFruits[key] = fruits[key];&#125;);console.log(sortedFruits);/*&#123; apples: false, Bananas: true, Oranges: true&#125;*/ 对象数组（按对象键排序）1234567891011let fruits = [ &#123; Bananas: true &#125;, &#123; Apples: false &#125;, &#123; oranges: true &#125;]; 可能这是上述情况中最复杂，但是结合所有的方法，其实也很简单🐶","categories":[],"tags":[{"name":"Javascript, array","slug":"Javascript-array","permalink":"http://shenye.me/tags/Javascript-array/"}]}]}