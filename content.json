{"meta":{"title":"Shane In Tech Life","subtitle":"as above","description":"Shane's blog","author":"Shane Ye","url":"http://shenye.me","root":"/"},"pages":[],"posts":[{"title":"Azure Functions 连接 MongoDB","slug":"Azure Functions 连接 MongoDB","date":"2020-06-22T14:01:36.000Z","updated":"2020-07-13T14:37:24.038Z","comments":true,"path":"2020/06/22/Azure Functions 连接 MongoDB/","link":"","permalink":"http://shenye.me/2020/06/22/Azure Functions 连接 MongoDB/","excerpt":"","text":"前言无服务器架构计算变得越来越流行，但是，当使用无服务器架构来构建后端API时，经常会遇到一些小问题。使用无状态函数是否意味着必须在每次运行该函数时都建立与数据库的新连接？ 其实大多数问题都有解决方法，因此不必每次运行函数时花费额外的时间来连接数据库。所以今天准备写一下关于使用MongoDB驱动程序和mongoose与Azure Functions重复使用数据库连接的文章。本文将完成在Node.js中设置Azure Functions的过程，以及该函数将连接到MongoDB并在请求之间重用数据库连接。 创建一个简单的Azure函数在之前的文章中已经讲解了如何创建Azure Functions，这里也不再赘述。首先我们在Azure Portal上创建一个Azure Function。 安装MongoDB驱动程序接下来让我们将该功能连接到数据库。在Azure Function中添加npm模块与在AWS Lambda的过程非常不同。使用Azure Functions，必须登录到服务器，然后创建package.json，然后运行npm install。对于“无服务器”架构来说，这似乎很奇怪，但是好处就是不必一遍又一遍地捆绑相同的依赖，也不必担心node_modules运行在Lambda对函数大小的限制。 要安装MongoDB Node.js驱动程序，请首先转到.scm.azurewebsites.net，然后单击“调试控制台”-&gt;“ PowerShell”。 转到D:\\home\\site\\wwwroot目录下，新建名为的package.json文件，增加MongoDB一览，最后保存。 执行npm i 回到Azure Function编辑界面，写入代码。12345678910111213141516171819202122232425262728293031const mongodb = require('mongodb');// URI for MongoDB Atlas xxx为省略 https://www.mongodb.com/cloud/atlasconst uri = 'mongodb+srv://xxx.mongodb.net/test';module.exports = function (context, req) &#123; context.log('Running'); mongodb.MongoClient.connect(uri, function(error, client) &#123; if (error) &#123; context.log('Failed to connect'); context.res = &#123; status: 500, body: res.stack &#125; return context.done(); &#125; context.log('Connected'); client.db('test').collection('tests').find().toArray(function(error, docs) &#123; if (error) &#123; context.log('Error running query'); context.res = &#123; status: 500, body: res.stack &#125; return context.done(); &#125; context.log('Success!'); context.res = &#123; headers: &#123; 'Content-Type': 'application/json' &#125;, body: JSON.stringify(&#123; res: docs &#125;) &#125;; context.done(); &#125;); &#125;);&#125;; 重用数据库连接但是每次该函数运行时创建一个新的数据库连接会降低性能。所以与Lambda一样，可以使用Node.js运行时的小技巧来保留调用之间的数据库连接。具体来说，脚本中的全局变量可能在函数调用之间保留，因此，如果向MongoDB客户端添加全局指针，则它将一直保留，直到它被Azure清除它。 123456789101112131415161718192021222324252627282930313233343536373839404142434445const mongodb = require('mongodb');const uri = 'mongodb+srv://OMITTED/test';// May be retained between function executions depending on whether Azure// cleans up memorylet client = null;module.exports = function (context, req) &#123; context.log('Running'); let hasClient = client != null; if (client == null) &#123; mongodb.MongoClient.connect(uri, function(error, _client) &#123; if (error) &#123; context.log('Failed to connect'); context.res = &#123; status: 500, body: res.stack &#125; return context.done(); &#125; client = _client; context.log('Connected'); query(); &#125;); &#125; else &#123; query(); &#125; function query() &#123; client.db('test').collection('tests').find().toArray(function(error, docs) &#123; if (error) &#123; context.log('Error running query'); context.res = &#123; status: 500, body: res.stack &#125; return context.done(); &#125; context.log('Success!'); context.res = &#123; headers: &#123; 'Content-Type': 'application/json' &#125;, body: 'Num docs ' + docs.length + ', reused connection ' + hasClient &#125;; context.done(); &#125;); &#125;&#125;; 第一次运行会创杰数据库连接，第二次运行就会从全局变量中拿到以前的连接。很明显会更快。 最后Azure Functions不需要您捆绑node_modules，而是让您在功能应用程序中的多个功能之间共享node_modules。Azure Functions可以大规模执行代码，而不必担心置备和管理基础虚拟机和操作系统。MongoDB使开发人员能够快速将想法变为现实，而不会影响数据库的工作效率。 Azure平台和MongoDB一起为开发人员提供了一套快速开发的环境。","categories":[],"tags":[{"name":"Serverless, Azure, Azure Function, MongoDB","slug":"Serverless-Azure-Azure-Function-MongoDB","permalink":"http://shenye.me/tags/Serverless-Azure-Azure-Function-MongoDB/"}]},{"title":"为什么React需要Hooks","slug":"为什么React需要Hooks","date":"2020-05-28T02:24:23.000Z","updated":"2020-06-17T03:15:13.205Z","comments":true,"path":"2020/05/28/为什么React需要Hooks/","link":"","permalink":"http://shenye.me/2020/05/28/为什么React需要Hooks/","excerpt":"","text":"前言如果你是一个React开发者，那么你经常会听到关于React hooks，也就是所说的钩子的讨论。而对于那些没有使用过React hooks的开发者来说，这只是React内置的函数，它们可以让我们让在functional组件内里做所有可以在class组件内做的事。 但是为什么要使用React hooks呢？ 如果类组件可以完成我们希望它们做的所有事情，比如初始化状态，设置状态，访问组件的生命周期，创建上下文，调用引用等，那么我们为什么要为我们的展示性组件提供一种方法，做同样的事情呢？functional组件有什么特别之处？ 好吧，事实证明，使用钩子为开发人员带来好处的原因有很多。首先是大型组件可能难以使用，在大型项目上工作的开发者们，组件的状态可能会越来愈多，愈来愈复杂，其大小经常会在组件生命周期方法中散布相同或相似的逻辑。第二个是方法重用，重用组件方法（尤其是复杂的逻辑）依赖于设计模式，例如高阶组件或渲染参数，这反过来又需要开发人员重新组织其组件层次结构，并可能导致组件层级混乱。最后，类语法对卡发者和编译器都造成了混淆，并且可能导致React所追求的纯粹的功能设计模式无法实现。 那么钩子如何解决这些问题呢？ 组件大小当涉及到组件的规模，大小时，钩子使用useEffect提取生命周期方法中的许多重复功能，并使用useState初始化，改变状态。例如，一个useEffect挂钩可以完成3种生命周期方法的工作：componentDidMount，componentDidUpdate和componentWillUnmount。通过指定一个可选的依赖项数组，您可以告诉useEffect在指定的状态引用中查找更改，然后再次运行该效果，等效于componentDidUpdate。通过指定一个空的依赖关系数组，您可以告诉useEffect仅运行一次componentDidMount。当从DOM中删除组件时，您需要执行一些数据清除操作（例如清除间隔或阻止api调用），您可以在return语句中为useEffect回调，该语句将在unmount- componentWillUnmount上运行。所有这些工作都可以通过一个useEffect调用来完成，这使其成为解决副作用的强大方法！ 方法复用在应用中其他地方重用组件逻辑时，我们概括这些方案的传统方式是使用渲染道具或HOC（高阶组件）。渲染道具的工作方式是将带有独立JSX的自定义回调作为参数,传递给我们的组件。当我们希望相同的渲染组件的多个实例之间重用时，就可以这样。例如，如果我们想通过一个组件跟踪鼠标的位置，但想对该数据做不同的事情（例如在p标签而不是h1标签中显示位置），则可以通过指定渲染擦输来实现使用定制的JSX。 12&lt;MousePosition render = &#123;position =&gt; &lt;p&gt;&#123;position&#125;&lt;/p&gt;&#125;&gt;&lt;/MousePosition&gt;&lt;MousePosition render = &#123;position =&gt; &lt;h1&gt;&#123;position&#125;&lt;/h1&gt;&#125;&gt;&lt;/MousePosition&gt; HOC（高阶组件）通过创建包装器组件或返回包装器组件的函数来实现，该函数使包装的组件可以访问某些数据或功能。如果多个组件正在执行相似但略有不同的工作，例如从相同来源获取某些数据但使用不同方法，则我们将希望使用此功能。想想Redux的connect（）函数，它将包装好的组件连接到我们的商店。这里可能需要连接多个组件，但是状态和调度方法的需求却有所不同。因此，我们可以向我们的连接HOC提供自定义的mapStateToProps和mapDispatchToProps函数，以为包装的组件提供个性化数据。 1export default connect(mapStateToProps, mapDispatchToProps)(SomeComponent); 尽管这些模式对于类组件非常有效，但它们也有缺点。特别是，它们要求开发人员重写其组件层次结构，并可能导致包装器地狱的第9个循环。 React hooks的替代方法是允许我们的可以调用以自定义hook的形式在各​​个组件之间共享。自定义钩子只是可组合的函数，可以像其他任何函数一样在组件之间导出和共享。可组合的意思是指具有多个部分（例如useState和useEffect调用），将它们组合为可重用模式并将其抽象为自己的单独功能的能力。这种模式在类组件中将是不可能的，因为做诸如获取数据或实例化状态之类的简单操作不能与调用它们的类方法分开。 性能与困惑最后，大家对于类组件的性能其实没有什么担心。在2018年React Conference上，当React Hooks揭幕时，有人指出类组件对于机器和人类都很难理解。由于类语法只是JavaScript原型继承的一种语法糖，因此类的工作方式与其他编程语言不同。React团队注意到在生产环境中最小化类组件的问题，并且在实现热模块重新加载时存在不一致之处。此外，对于开发者，尤其是对那些刚接触类语法的开发者来说，可能很难理解’this’关键字的绑定是如何工作的，或者难以理解其他类的细微差别，例如在构造函数内部调用super（）的目的。 由于React hooks使我们能够在功能组件内部使用所有相同的类组件功能，因此我们能够提高React代码的性能。此外，钩子具有简洁的语法，不仅与React的纯功能设计紧密相关，而且与JavaScript紧密相关。 React在其他基于组件的前端库（如Vue）之间的主要区别之一是它通过JSX和css模块将html，css和JavaScript耦合在一起。这意味着，如果你是JavaScript专家，那么您就是React（提供或获取实现细节）专家，而不是像过去那样依赖Vue在HTML，CSS和JS之间拆分文件的模板结构jQuery和Vanilla JS的DOM处理的概念。 尽管功能组件的性能略有提高，但性能不应成为使用React hooks的主要原因。它也不会在React中添加尚不存在的任何功能。其主要目的只是简单地将功能组件提升到与类组件相同的级别，从而通过更干净，更可维护的代码，更好地在组件之间重用方法以及更简单，更具声明性的使用方式，从而获得更好的DX（开发人员体验）。 话虽这么说，但我有一些同事发现React hooks在概念上不容易掌握，尤其是在了解useEffect，useState或useContext时。例如，很难看到应该如何将生命周期方法中的各种逻辑组合成单个函数调用。因此，最近，有开发者创建了一个称为Hookd的CLI模板工具，以将类组件立即转换为带有钩子的功能组件。 清理代码，理清思路最后，使用React hooks似乎不仅仅是开发者“装x”的工具，它可以让开发人者清理自己的代码，进而理清自己的思路。所以不应低估简洁和声明性代码提高的可读性，开发效率和模块化且可维护的应用程序的重要性。在AI代替人类编程之前，我们必须遵循这些可以让打击都清楚理解的约束，这样才有助于项目壮大。","categories":[],"tags":[{"name":"Serverless, Azure, Azure Function","slug":"Serverless-Azure-Azure-Function","permalink":"http://shenye.me/tags/Serverless-Azure-Azure-Function/"}]},{"title":"如何使用VS Code快速部署Azure Function","slug":"Azure Function Part II","date":"2020-05-05T13:15:33.000Z","updated":"2020-05-09T07:22:03.504Z","comments":true,"path":"2020/05/05/Azure Function Part II/","link":"","permalink":"http://shenye.me/2020/05/05/Azure Function Part II/","excerpt":"","text":"前言本文将介绍部署Azure Function的完整过程。这一次会使用Node.js作为开发语言，以及使用VS Code作为编辑器。 在后面的博文中会写到如何提高Node.js Azure functions的性能。 进入正题首先在Azure portal上创建一个Function App然后选择使用VS Code做为开发环境。 我们先了解一些基本参数： App name：functions群组的唯一名称。这也是资源最终URL的尾部。比如App name是example，URL就会是example.azurewebsites.net Subscription: 选择你的订阅 Resource group &amp; version: 选择开发语言和版本 OS: Windows是默认的选项，但是你也可以使用Linux Runtime stack: 我们选择node，版本选择10 Publish: 发布类型，我们选择code Hosting plan: 现在一个消费计划，Azure Fuctions计费已次计算，很便宜。具体参考Azure functions定价 Location: 选择一个资源的位置，中国速度最快应该是东亚地区 Application Insights: 用于记录日志定位问题 点击创建过几分钟之后，会提示创建成功。 然后我们选择VS Code作为开发环境 提示我们需要安装所需工具，在上一篇博文中，我们介绍安装了开发Azure Functions的工具。这里不再赘述。 我们推荐在VS Code中安装两个扩展： Azure Account: 整合Azure账户和VS Code. Azure Functions: 帮助我们创建，维护，管理，部署function 下一步我们登录的我们的Azure账号，然后我们就可以看到我们刚刚建立的Function App 现在可以使用Azure Functions扩展床一个HTTP trigger的function 然后输入Function名称，选择‘Function’作为缱绻等级 现在我们已经创建了一个function。主文件是index.js。这是一个模版，它接受一个get或post请求，在参数中如果有name字段，则返回“Hello ” + (req.query.name || req.body.name)，否则返回400错误. 另外一个重要的文件是function.json，它包含了一些配置。比较常用的配置是HTTP请求方式。你可以选择GET, POST, PUT, DELETE, OPTIONS等。 测试你的Function然后部署到Azure本地运行之后，我们可以断点进行调试。 接下来我们要部署到这个function，选中function名称，右键，选择“Deploy to Function App…” 选择你想部署到的Fnction App 如果没有问题，我们可以收到一个部署成功的提示 总结使用VS Code开发是非常高效的，它集合Azure官方的扩展，所以很容易地本地开发和部署到Azure。","categories":[],"tags":[{"name":"Serverless, Azure, Azure Function, VS Code","slug":"Serverless-Azure-Azure-Function-VS-Code","permalink":"http://shenye.me/tags/Serverless-Azure-Azure-Function-VS-Code/"}]},{"title":"Azure Functions - 配置开发环境","slug":"Azure Function Part I","date":"2020-03-29T12:55:10.000Z","updated":"2020-04-08T01:50:42.196Z","comments":true,"path":"2020/03/29/Azure Function Part I/","link":"","permalink":"http://shenye.me/2020/03/29/Azure Function Part I/","excerpt":"","text":"前言说Azure functions之前先来说说Serverless。Serverless是最近很火的一个概念，它是一种基于互联网的技术架构理念，应用逻辑并非全部在服务端实现，而是采用FAAS（Function as a Service）架构，通过功能组合来实现应用程序逻辑。应用业务逻辑将基于FAAS架构形成独立为多个相互独立功能组件，并以API服务的形式向外提供服务；很多公司都在自己的云平台推出了FAAS，比如Amazon Lambda，Azure Function，Google Cloud Functions，阿里云Function Compute等。 微软的Azure functions是基于Azure的无服务器计算服务，可以快速的帮助用户构建一个基于事件驱动的应用架构。用户无需关心服务器的部署运营，只需专注于核心的逻辑，既可以发布上线。费用按照实际调用次数与时长计费，自动缩放，仅在运行函数时为计算资源付费。更棒的是Azure Functions支持C#，Python，Javascript，TypeScript，F#和Java，本文带大家快速看在本地搭建Javascript开发环境开发Azure Functions。 环境安裝可以使用Visual Studio Code和Visual Studio开发，本文将会使用的VS Code。 首先在扩展市场中搜索Azure functions，你也可以直接安裝Azure App Service，这样你就拥有所有相关扩展服务，也可以仅安裝Azure Functions。 接著，我们要安裝 Azure Function Core Tools，在命令行安装： 12345678910#via npmnpm i -g azure-functions-core-tools --unsafe-perm true#Linuxwget -q https://packages.microsoft.com/config/ubuntu/19.04/packages-microsoft-prod.debsudo dpkg -i packages-microsoft-prod.deb#Macbrew tap azure/functionsbrew install azure-functions-core-tools 或者我们可以点击Debug | Run, VS Code会自动提示安装Azure Function Core Tools，确定后自动执行上方命令。 安裝成功之后，我们可以在命令行输入 func 来检查是否安装成功。 出现 闪电 就说明安装成功了！ ##预告 下一篇博文将会讲到 如何快速部署Azure Function","categories":[],"tags":[{"name":"Serverless, Azure, Azure Function","slug":"Serverless-Azure-Azure-Function","permalink":"http://shenye.me/tags/Serverless-Azure-Azure-Function/"}]},{"title":"Javascript - 排序排序的小技巧","slug":"Javascript - 排序排序的小技巧","date":"2020-02-28T11:34:40.000Z","updated":"2020-04-01T04:57:55.188Z","comments":true,"path":"2020/02/28/Javascript - 排序排序的小技巧/","link":"","permalink":"http://shenye.me/2020/02/28/Javascript - 排序排序的小技巧/","excerpt":"","text":"普通数组:1let fruits = [`bananas`, `Apples`, `Oranges`]; 很简单，一行搞定： 1fruits.sort(); 但是要注意数组中不同字符串的大小写不一致… 大写的字符会被排在小写字符之前😂所以还有其他的步骤： 1234567let fruits = [`bananas`, `Apples`, `Oranges`];fruits.sort((a, b) =&gt; &#123; return a.toLowerCase().localeCompare(b.toLowerCase());&#125;)console.log(fruits);// [\"Apples\", \"bananas\", \"Oranges\"] 对象数组（按对象键值排序）对对象数组的排序会变得很稍微更复杂一些。经常我们会在处理JSON API的时候遇到。 1234567891011let fruits = [ &#123; fruit: `Bananas` &#125;, &#123; fruit: `apples` &#125;, &#123; fruit: `Oranges` &#125;]; 我们可以为此写一个排序函数，但是更进一步我们需要一个更通用的方法把需要排序的键以参数的形式传进去 1234567891011121314const propComparator = (propName) =&gt; (a, b) =&gt; a[propName].toLowerCase() == b[propName].toLowerCase() ? 0 : a[propName].toLowerCase() &lt; b[propName].toLowerCase() ? -1 : 1So now we can use it to sort:fruits.sort(propComparator(`fruit`));console.log(fruits);/*[ &#123;fruit: \"apples\"&#125;, &#123;fruit: \"Bananas\"&#125;, &#123;fruit: \"Oranges\"&#125;]*/ 普通对象如果我们有个对象是这样的： 12345let fruits = &#123; Bananas: true, apples: false, Oranges: true&#125;; 我们依然可以将那些键小写化，然后我们先排序键的数组，然后用排序好的键数组建一个新对象 123456789101112131415let sortedFruits = &#123;&#125;;Object.keys(fruits).sort((a, b) =&gt; &#123; return a.toLowerCase().localeCompare(b.toLowerCase());&#125;).forEach(function(key) &#123; sortedFruits[key] = fruits[key];&#125;);console.log(sortedFruits);/*&#123; apples: false, Bananas: true, Oranges: true&#125;*/ 对象数组（按对象键排序）1234567891011let fruits = [ &#123; Bananas: true &#125;, &#123; Apples: false &#125;, &#123; oranges: true &#125;]; 可能这是上述情况中最复杂，但是结合所有的方法，其实也很简单🐶","categories":[],"tags":[{"name":"Javascript, array","slug":"Javascript-array","permalink":"http://shenye.me/tags/Javascript-array/"}]}]}