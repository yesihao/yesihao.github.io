{"meta":{"title":"Shane In Tech Life","subtitle":"as above","description":"Shane's blog","author":"Shane Ye","url":"http://yesihao.com","root":"/"},"pages":[],"posts":[{"title":"静谧的CSS斑驳灯光效果","slug":"静谧的CSS斑驳灯光效果","date":"2022-01-16T10:44:11.000Z","updated":"2022-02-28T14:45:41.585Z","comments":true,"path":"2022/01/16/静谧的CSS斑驳灯光效果/","link":"","permalink":"http://yesihao.com/2022/01/16/%E9%9D%99%E8%B0%A7%E7%9A%84CSS%E6%96%91%E9%A9%B3%E7%81%AF%E5%85%89%E6%95%88%E6%9E%9C/","excerpt":"","text":"前言傍晚的阳光透过沙沙作响的树叶照射进来，给人宁静而温暖的感觉。许多艺术家使用斑驳的光来营造一种柔和、催眠的效果。 斑驳效果我们可以在网页设计中使用同样的斑驳效果。使用在照片和插图上，可以为原本单调乏味的内容墙增添魔力，让它们恢复生机。有一种只用 CSS 的简单而快速的方法来添加这个效果。 在我们开始谈代码之前，了解斑驳光的组成很重要。它是光透过树叶和树枝形成的大光点组成的。因为我们正在谈论的是穿过许多不确定的空间的光，有时阴影区域有清晰的边缘，但更多时候是模糊的。当光从更远的距离投射阴影时，会扩散和扭曲光线附近的墙壁，使得阴影的边界变得模糊。这是有和没有斑驳光照射的白墙的区别： 我将会使用纯文本和有趣的表情符号来创造斑驳的灯光效果，使用 CSS 阴影和混合来模仿自然。我也将会介绍一些其他的方法。 设置场景我们将使用文本（字母表中的字母、特殊字符、表情符号等）来创建光的形状。我所说的光，是指半透明的乳白色。同时，我们想要的是柔和的灯光效果，而不是那种锐利、清晰或鲜明的效果。 由斑驳的光产生的斑点有多种形状，所以最好的选择是椭圆或长方形的字符。我会使用 🍃、🍂，\\因为它们是椭圆的、长方形的和倾斜的，有点混乱且难以预测。 我将它们包装在 .backdrop 父元素中包含的段落中： 12345&lt;div class=&quot;backdrop&quot;&gt; &lt;p class=&quot;shapes&quot;&gt;🍃&lt;/p&gt; &lt;p class=&quot;shapes&quot;&gt;🍂&lt;/p&gt; &lt;p class=&quot;shapes&quot;&gt;\\&lt;/p&gt;&lt;/div&gt; 我使用父元素作为投射斑驳光影的表面，为其纹理应用背景图像。我不仅给表面一个明确的 width 和 height，而且在它上面设置了隐藏的溢出，这样我就可以投射超出表面的阴影而不暴露它们。由于 CSS 网格，投射出斑驳光效果的对象在背景表面的中间对齐： 12345678910.backdrop &#123; background: center / cover no-repeat url(&#x27;image.jpeg&#x27;); width: 400px; height: 240px; overflow: hidden; display: grid;&#125;.backdrop &gt; * &#123; grid-area: 1/1;&#125; 如果形状没有完全对齐也没有关系，只要它们能够达到你想要的斑驳的效果，就可以了。所以没有必要完全按照我的做法来放置这些东西，你可以尝试调整这些值来获得不同图案的斑驳光！ 在 CSS 中设计斑驳的灯光这些是表情符号应该具有的关键属性——transparent 颜色、黑色半透明背景（使用 alpha 通道 inrgbargba()）、font-size 漂亮的模糊白色 text-shadow，最后是 mix-blend-mode 来平滑过渡。mix-blend-mode 设置元素的颜色与其容器的内容的融合方式。该 multiply 值使元素的背景通过元素的浅色显示并保持深色相同，从而产生更好、更自然的斑驳光效果。 1234567.shapes &#123; color: transparent; background-color: rgba(0, 0, 0, 0.3); // Use alpha transparency text-shadow: 0 0 40px #fff; // Blurry white shadow font: bolder 320pt/320pt monospace; mix-blend-mode: multiply;&#125; 细化颜色和对比度我希望背景上的 background-image 更亮一点，所以我还添加了 filter: brightness(1.6). 另一种实现方法是 background-blend-mode，将一个元素的所有不同背景混合在一起，而不是将表情符号添加为单独的元素，我们将它们添加为背景图像。请注意，在最后一个示例中，我使用了不同的表情符号，以及 floralwhite 一些比纯白色的光线强度更低的颜色。这是展开的表情符号背景图像之一： 123456789101112&lt;svg xmlns=&#x27;http://www.w3.org/2000/svg&#x27;&gt; &lt;foreignObject width=&#x27;400px&#x27; height=&#x27;240px&#x27;&gt; &lt;div xmlns=&#x27;http://www.w3.org/1999/xhtml&#x27; style= &#x27;font: bolder 720pt/220pt monospace; color: transparent; text-shadow: 0 0 40px floralwhite; background: rgba(0, 0, 0, 0.3);&#x27; &gt; 🌾 &lt;/div&gt; &lt;/foreignObject&gt;&lt;/svg&gt; 如果想将自己的图像用于形状，要确保边界模糊以创造柔和的光线。CSS blur()过滤器可以很方便地处理同样的事情。我还使用 CSS@supports 来调整某些浏览器的阴影模糊值作为后备。现在让我们回到第一个示例并添加一些内容： 123456789101112131415161718&lt;div class=&quot;backdrop&quot;&gt; &lt;p class=&quot;shapes&quot;&gt;🍃&lt;/p&gt; &lt;p class=&quot;shapes&quot;&gt;🍂&lt;/p&gt; &lt;p class=&quot;shapes&quot;&gt;\\&lt;/p&gt;&lt;/div&gt;&lt;p class=&quot;content&quot;&gt; &lt;img width=&quot;70px&quot; style=&quot;float: left; margin-right: 10px;&quot; src=&quot;image.jpeg&quot; alt=&quot;&quot; /&gt; Top ten tourists spots for the summer vacation &lt;br /&gt;&lt;br /&gt;&lt;i style=&quot;font-weight: normal;&quot; &gt;Here are the most popular places...&lt;/i &gt;&lt;/p&gt; .backdrop 和.shapes 以前的风格基本相同。至于.content 同样位于 之上的.backdrop，我添加 isolation: isolate 以形成一个新的堆叠上下文，将元素从混合中排除，作为一种精炼的触感。 动画光源我还决定添加一个简单的 CSS 动画，并将@keyframes 其应用于.backdrop :hover： 1234567891011121314151617181920212223.backdrop:hover &gt; .shapes:nth-of-type(1) &#123; animation: 2s ease-in-out infinite alternate move;&#125;.backdrop:hover &gt; .shapes:nth-of-type(2):hover &#123; animation: 4s ease-in-out infinite alternate move-1;&#125;@keyframes move &#123; from &#123; text-indent: -20px; &#125; to &#123; text-indent: 20px; &#125;&#125;@keyframes move-1 &#123; from &#123; text-indent: -60px; &#125; to &#123; text-indent: 40px; &#125;&#125; 为 emoji 上的 text-indent 属性设置动画会产生一种非常微妙的运动，就像移动的云层改变光线的方向。 总结好了！我们从自然和艺术中汲取了一些灵感，模仿了太阳穿过树木和灌木丛，将斑驳的光和阴影点投射到物体的表面。我们用 CSS 和几个表情符号完成了所有这些。 这个方法的关键在于我们如何在表情符号上应用颜色，在浅色中使用额外的模糊 text-shadow 来设置光线，半透明的 background-color 定义阴影斑点。我们所要做的就是确保光影的背景使用具有足够对比度的逼真的纹理，这样就能看到斑驳的光线了。","categories":[],"tags":[{"name":"CSS, Effect, 灯光效果","slug":"CSS-Effect-灯光效果","permalink":"http://yesihao.com/tags/CSS-Effect-%E7%81%AF%E5%85%89%E6%95%88%E6%9E%9C/"}]},{"title":"CSS “decorations” 装饰","slug":"CSS “decorations” 装饰","date":"2021-12-26T15:41:09.000Z","updated":"2021-12-27T12:14:40.251Z","comments":true,"path":"2021/12/26/CSS “decorations” 装饰/","link":"","permalink":"http://yesihao.com/2021/12/26/CSS%20%E2%80%9Cdecorations%E2%80%9D%20%E8%A3%85%E9%A5%B0/","excerpt":"","text":"前言在 Wikipedia 的Common.css有一段 CSS 123456.mw-collapsible-leftside-toggle .mw-collapsible-toggle &#123; /* @noflip */ float: left; /* @noflip */ text-align: left;&#125; 这里的@noflip 有什么用呢？这就是一些人所说的“CSS 装饰”，我觉得这很形象。实际上，它们只是 CSS 注释而已，但显然这里还有更多内容，因为它们看起来像具有功能的语句。 如果没有某种 CSS 处理过程，这些注释将无济于事。我不是很确定这里使用的是什么 CSS 处理器，但我认为假设它运行时会产生一个“从右到左”的样式表是合理的，它会变成浮动：左 进入浮动：右和文本对齐：左进入文本对齐：右。 替代方案？我认为值得注意的是，现在使用大多数浏览器支持的 text-align: start 效果可能更好，这样就不必依赖 CSS 处理和备用样式表来修改 CSS。但是我觉得 float 是没有“逻辑”等价物，但可能有一种方法可以重构布局（使用grid？），这样“翻转”就是不必要的。将元素包裹在一个元素周围对于浮动来说是非常独特的，所以这里可能没有简单的替代方案。 稍微搜索了一下，似乎是 /* @noflip */ 的来源is CSSJanus 这个仓库显示它是由维基媒体制作的，所以我认为这是一个已解决的案例。看起来这项技术已经运用到其他，比如样式组件的插件，Sublime Text 的插件，Salesforce 甚至在他们的设计系统中使用了它。 还有另一个名为 css-flip 的处理器（现在已归档，出自 Twitter）看起来它做了完全相同的事情，自述文件显示了有多少属性可能需要这个： 1background-position, background-position-x, border-bottom-left-radius, border-bottom-right-radius, border-color, border-left, border-left-color, border-left-style, border-left-width, border-radius, border-right, border-right-color, border-right-style, border-right-width, border-style, border-top-left-radius, border-top-right-radius, border-width, box-shadow, clear, direction, float, left, margin, margin-left, margin-right, padding, padding-left, padding-right, right, text-align transition transition-property 总结It would have hugely surprised me if there wasn’t a PostCSS plugin for this, and a little searching turned up postcss-rtl, but alas, it’s also been deprecated by the owner. This all started with talking about “CSS decorators” though, which I guess we’re defining as “CSS comments that have processor directives in them.” The one I personally use the most is this: 我想一定会一个实现 flip 的PostCSS 插件，然后我就搜索到了 postcss-rtl，但是它也被所有者弃用了 ☹️。 不过，这一切都始于谈论“CSS 装饰”，我想我们应该将其定义为“其中包含处理器指令的 CSS 注释”。 我个人用得最多的是这个： 12345678910/* prettier-ignore */.cool &#123; linear-gradient( to left, pink pink 20% red 20% red )&#125; 我很喜欢 Prettier，但如果我花时间自己格式化一些 CSS 以提高可读性，我会在前一行中添加一个 /* prettier-ignore */ 以格式化的时候弄乱它。","categories":[],"tags":[{"name":"CSS, decorations, 装饰","slug":"CSS-decorations-装饰","permalink":"http://yesihao.com/tags/CSS-decorations-%E8%A3%85%E9%A5%B0/"}]},{"title":"通过拉取请求更好地协作","slug":"通过拉取请求更好地协作","date":"2021-11-24T11:16:55.000Z","updated":"2021-12-06T14:54:11.429Z","comments":true,"path":"2021/11/24/通过拉取请求更好地协作/","link":"","permalink":"http://yesihao.com/2021/11/24/%E9%80%9A%E8%BF%87%E6%8B%89%E5%8F%96%E8%AF%B7%E6%B1%82%E6%9B%B4%E5%A5%BD%E5%9C%B0%E5%8D%8F%E4%BD%9C/","excerpt":"","text":"Pull Request 拉取请求——这是一项对小型和大型开发团队都有帮助的强大功能。拉取请求不仅可以改进审查和反馈过程，而且还有助于跟踪和讨论代码更改。最后但并非最不重要的一点是，它是为你没有写入权限的其他存储库做出贡献的理想方式。 什么是拉取请求？首先，要明白拉取请求并不是 Git 的核心功能。相反，它们是由你使用的 Git 托管平台提供的： GitHub、GitLab、Bit bucket、AzureDevops 和其他一些平台都内置了这样的功能。 为什么要创建拉取请求？在我们详细了解如何创建完美的拉取请求之前，让我们先谈谈你为什么会想要使用此功能。 想象一下，你刚刚完成了软件的一项新功能。也许你一直在一个功能分支中工作，所以你的下一步是将它合并到主线分支（master或main）。这在某些情况下没有任何问题，例如，你是项目中唯一的开发人员，或者你有足够的经验并且知道你的团队成员肯定会对此感到高兴。但是，如果你的更改有点复杂并且你希望其他人查看你的工作怎么办？这就是拉取请求的目的，通过拉取请求，你可以邀请其他人审查你的工作并向你提供反馈。拉取请求打开后，你可以与其他开发人员讨论你的代码。大多数 Git 托管平台允许其他用户在此过程中添加评论并提出更改建议。在你的审阅者批准你的工作后，它可能会合并到另一个分支中。 但是，拥有审查工作流程并不是拉取请求的唯一原因。如果你想为你没有写入权限的其他存储库做出贡献，它们会派上用场。想想那里的所有开源项目，如果你有一个新功能的想法，或者如果你想提交补丁，拉取请求是一种很好的方式来表达你的想法，而无需加入项目并成为主要贡献者。这将我们带到了一个与拉取请求紧密相关的主题：forks。 使用forks工作forks是现有Git仓库的个人副本。回到我们的开源示例：你的第一步是创建原始存储库的分支。之后，你可以在自己的个人副本中更改代码。完成后，你打开一个拉取请求，要求原始存储库的所有者包含你的更改。所有者或其他主要贡献者之一可以查看你的代码，然后决定包含（或不包含）它。让审阅者的生活更轻松：如何创建出色的拉取请求如前所述，拉取请求不是 Git 的核心功能。相反，每个 Git 平台都有自己的设计和关于拉取请求应该如何工作的想法。它们在 GitLab、GitHub、Bitbucket 等上看起来不同。每个平台都有略微不同的跟踪、讨论和审查更改的工作流程。 例如，像Tower Git 客户端这样的桌面GUI可以使这变得更容易：它们提供一致的用户界面，无论你使用什么代码托管服务。 话虽如此，一般工作流程始终相同，包括以下步骤： 如果你没有相关存储库的写入权限，第一步是创建一个分支，即你的存储库的个人版本。 在你的分叉存储库中创建一个新的本地分支。（提醒：拉取请求基于分支，而不是提交！） 在你的本地分支中进行一些更改并提交。 将更改推送到你自己的远程存储库。 使用你的更改创建拉取请求并开始与其他人讨论。 让我们看看拉取请求本身以及如何创建一个让其他开发人员的生活更轻松的请求。首先，它应该很短，以便可以快速查看。当查看 3,000 行而不是 30 行时，更难理解代码。此外，请确保添加一个良好且不言自明的标题和有意义的描述。尝试描述什么，你变了，为什么你开拉入请求，以及如何更改影响的项目。大多数平台都允许你添加有助于演示更改的屏幕截图。 批准、合并还是拒绝？一旦你的更改获得批准，你（或具有写入权限的人）就可以将分叉分支合并到主分支中。但是如果审阅者不想合并当前状态的拉取请求怎么办？好吧，你总是可以添加新的提交，在推送那个分支之后，现有的拉取请求就会更新。或者，所有者或其他具有写入权限的人可以在他们不想合并更改时拒绝拉取请求。 开发商的安全网如你所见，拉取请求是与开发人员同事交流和协作的好方法。通过请其他人审查你的工作，你可以确保只有高质量的代码才能进入你的代码库。","categories":[],"tags":[{"name":"git, Pull Request, 协作","slug":"git-Pull-Request-协作","permalink":"http://yesihao.com/tags/git-Pull-Request-%E5%8D%8F%E4%BD%9C/"}]},{"title":"JS 中的事件绑定、事件监听、事件委托是什么？","slug":"JS 中的事件绑定、事件监听、事件委托是什么？","date":"2021-10-26T12:16:33.000Z","updated":"2021-11-09T06:41:42.874Z","comments":true,"path":"2021/10/26/JS 中的事件绑定、事件监听、事件委托是什么？/","link":"","permalink":"http://yesihao.com/2021/10/26/JS%20%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E3%80%81%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"","text":"在JavaScript的学习中，我们经常会遇到JavaScript的事件机制，例如，事件绑定、事件监听、事件委托（事件代理）等。这些名词是什么意思呢，有什么作用呢？ 事件绑定要想让 JavaScript 对用户的操作作出响应，首先要对 DOM 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称。 在JavaScript中，有三种常用的绑定事件的方法： 在DOM元素中直接绑定；在JavaScript代码中绑定；绑定事件监听函数。 我们可以在DOM元素上绑定onclick、onmouseover、onmouseout、onmousedown、onmouseup、ondblclick、onkeydown、onkeypress、onkeyup等。好多不一一列出了。如果想知道更多事件类型请查看，DOM事件。 在JavaScript代码中绑定事件在JavaScript代码中（即script标签内）绑定事件可以使JavaScript代码与HTML标签分离，文档结构清晰，便于管理和开发。 使用事件监听绑定事件绑定事件的另一种方法是用 addEventListener() 或 attachEvent() 来绑定事件监听函数。下面详细介绍，事件监听。 事件监听关于事件监听，W3C规范中定义了3个事件阶段，依次是捕获阶段、目标阶段、冒泡阶段。 起初Netscape制定了JavaScript的一套事件驱动机制（即事件捕获）。随即IE也推出了自己的一套事件驱动机制（即事件冒泡）。最后W3C规范了两种事件机制，分为捕获阶段、目标阶段、冒泡阶段。IE8以前IE一直坚持自己的事件机制（前端人员一直头痛的兼容性问题），IE9以后IE也支持了W3C规范。 W3C规范语法： 1element.addEventListener(event, function, useCapture) event : （必需）事件名，支持所有DOM事件。 function：（必需）指定要事件触发时执行的函数。 useCapture：（可选）指定事件是否在捕获或冒泡阶段执行。true，捕获。false，冒泡。默认false。 事件监听的优点 1、可以绑定多个事件。常规的事件绑定只执行最后绑定的事件。两个事件都执行了。 2、可以解除相应的绑定 封装事件监听12345678//绑定监听事件function addEventHandler(target,type,fn)&#123; if(target.addEventListener)&#123; target.addEventListener(type,fn); &#125;else&#123; target.attachEvent(&quot;on&quot;+type,fn); &#125;&#125; 12345678//移除监听事件function removeEventHandler(target,type,fn)&#123; if(target.removeEventListener)&#123; target.removeEventListener(type,fn); &#125;else&#123; target.detachEvent(&quot;on&quot;+type,fn); &#125;&#125; 12345//测试var btn5 = document.getElementById(&quot;btn5&quot;);addEventHandler(btn5,&quot;click&quot;,hello1);//添加事件hello1addEventHandler(btn5,&quot;click&quot;,hello2);//添加事件hello2removeEventHandler(btn5,&quot;click&quot;,hello1);//移除事件hello1 事件委托事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果。 12345678var btn6 = document.getElementById(&quot;btn6&quot;);document.onclick = function(event)&#123; event = event || window.event; var target = event.target || event.srcElement; if(target == btn6)&#123; alert(btn5.value); &#125;&#125; 事件委托可以提高JavaScript性能。事件委托可以显著的提高事件的处理速度，减少内存的占用。","categories":[],"tags":[{"name":"JS 事件","slug":"JS-事件","permalink":"http://yesihao.com/tags/JS-%E4%BA%8B%E4%BB%B6/"}]},{"title":"“显示/隐藏密码”的多种实现","slug":"“显示隐藏密码”的多种实现","date":"2021-09-27T13:56:11.000Z","updated":"2021-10-18T20:52:48.955Z","comments":true,"path":"2021/09/27/“显示隐藏密码”的多种实现/","link":"","permalink":"http://yesihao.com/2021/09/27/%E2%80%9C%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E5%AF%86%E7%A0%81%E2%80%9D%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"在HTML里，我们会使用input标签去处理密码。就像这样： 1&lt;input type=&quot;password&quot;&gt; 如果你使用它，你会在输入时字符会变成这样的小圆点 ••••••• 那是因为浏览器试图帮助提高安全性。如果它没有这样做，那么有人可能会从你的身边偷看你正在输入的内容。这应该比查看手指在键盘上按下的键更容易。 但是现在 UX 已经发生了一些变化，并且更常见的选项是： 我觉得显示/隐藏密码是个很通用的场景。这样我们就可以确保正确输入，并且不会遭受打错字的痛苦。 所以！ 该怎么办？ 1: 使用 type=”password”, 然后使用JavaScript切换到 type=”text”这就是现在大家通常会做的事情，因为它现在实际上适用于所有浏览器。 123456const input = document.querySelector(&quot;.password-input&quot;);if (input.getAttribute(&quot;type&quot;) === &quot;password&quot;) &#123; input.setAttribute(&quot;type&quot;, &quot;text&quot;);&#125; else &#123; input.setAttribute(&quot;type&quot;, &quot;password&quot;);&#125; 这里的问题是除了你必须为此更改输入类型有点奇怪之外，还有是对密码管理器工具失效。 2: 在CSS使用 -webkit-text-security这不是一个特别通用的方案，因有些浏览器不支持这个属性。 123456input[type=&quot;password&quot;] &#123; -webkit-text-security: square;&#125;form.show-passwords input[type=&quot;password&quot;] &#123; -webkit-text-security: none;&#125; 3: 在CSS使用 input-security现在有个关于input security提案，我没可以切换input-security的值。我觉得这是一个比较好的提案，但是现在大多数浏览器还不支持，所以严格意义上说，我还只能用方案1。 123form.show-passwords input[type=&quot;password&quot;] &#123; input-security: none;&#125;","categories":[],"tags":[{"name":"input, dom, password, 隐藏密码","slug":"input-dom-password-隐藏密码","permalink":"http://yesihao.com/tags/input-dom-password-%E9%9A%90%E8%97%8F%E5%AF%86%E7%A0%81/"}]},{"title":"如何在 Node.js 中使用 ES6 import语法","slug":"如何在 Node.js 中使用 ES6 导入语法","date":"2021-08-28T14:56:21.000Z","updated":"2021-10-18T20:50:22.759Z","comments":true,"path":"2021/08/28/如何在 Node.js 中使用 ES6 导入语法/","link":"","permalink":"http://yesihao.com/2021/08/28/%E5%A6%82%E4%BD%95%E5%9C%A8%20Node.js%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20ES6%20%E5%AF%BC%E5%85%A5%E8%AF%AD%E6%B3%95/","excerpt":"","text":"新版Node.js模块是导出一个或多个值的 JavaScript 文件。导出的值可以是变量、对象或函数。 ES6 导入语法允许导入从不同 JavaScript 文件导出的模块。在 React 和 React Native 应用程序中使用模块是一种常见的模式。语法由以下 ES 模块标准组成： 1import XXX from &#x27;xxx&#x27;; ES 模块是使用模块的 ECMAScript 标准。Node.js 使用 CommonJS 标准来导入模块。这种标准的语法可以这样写： 1const XXX = require(&#x27;xxx&#x27;); Node js 不直接支持 ES6 导入。尝试import在 JS 文件中编写语法： 1import &#123; ApolloServer, gql &#125; from &#x27;apollo-server&#x27;; 使用npm start或运行Node.js服务器npm run dev 此错误的解决方案位于上述错误代码段的第一行，现在是 Node.js 推荐的方法。设置 “type”: “module” 在package.json文件。 123&#123; &quot;type&quot;: &quot;module&quot;&#125; 但是这个方案只适用于最新的 Node.js 和14.x.x+。 低于 14 的 Node.js这个问题的另一个解决方案是使用Babel。它是一个 JavaScript 编译器，允许使用最新的语法编写 JS。Babel 不是一个框架或平台，所以它可以用在任何用 JavaScript 编写的项目中，因此也可以用在 Node.js 项目中。 首先从终端窗口安装以下开发依赖项： 1npm i -D @babel/core @babel/preset-env @babel/node 然后在名为 Node.js 项目的根目录创建一个文件babel.config.json并添加以下内容： 123&#123; &quot;presets&quot;: [&quot;@babel/preset-env&quot;]&#125; 该包@babel/node是一个 CLI 程序，它在运行之前使用 Babel 预设和插件编译 Node.js 项目中的 JS 代码。这意味着它会babel.config.json在执行 Node 项目之前读取并应用任何提及的配置。 更换node用babel-node在执行服务器start或dev脚本。 使用npm run dev脚本运行 Node 服务器的示例： 12345&#123; &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;nodemon --exec babel-node server.js&quot; &#125;&#125;","categories":[],"tags":[{"name":"Node, import","slug":"Node-import","permalink":"http://yesihao.com/tags/Node-import/"}]},{"title":"CSS的检查工具","slug":"CSS的检查工具","date":"2021-07-20T12:11:39.000Z","updated":"2021-08-10T00:55:54.250Z","comments":true,"path":"2021/07/20/CSS的检查工具/","link":"","permalink":"http://yesihao.com/2021/07/20/CSS%E7%9A%84%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/","excerpt":"","text":"前言在开发人员的日常生活中，检查CSS并不常见，但有时不得不这样做。也许这是性能评估网页的一部分，为了找出关键的CSS并减少未使用的选择器。也许是为提高访问性，代码库中使用各种颜色对比突出。 无论情况如何，每当那一时刻到来时，我通常都会使用本文中将要介绍的一些工具。但在此之前，让我们首先看看“检查”CSS意味着什么。 检查CSS很困难一般来说，代码检查涉及分析代码以发现bug或其他不正常的地方，例如可能的性能问题。对于大多数编程语言来说，审核代码的概念相对简单:它是否有效。但是CSS是一种特殊的语言，在这种语言中，错误大多会被浏览器忽略。事实上，你可以通过许多不同的方式实现相同的风格。至少可以说，这使得CSS的检查有点棘手。 通过为您喜欢的代码编辑器使用扩展或设置检查器或代码检查器，可以防止发现这些错误。但这不是我想在这里展示的，这还不够。我们仍然可能会使用太多的颜色、排版定义或z-index，所有这些都可能导致CSS代码库混乱、不可维护、不稳定。 为了真正检查CSS，我们需要更深入地挖掘并找到那些是最佳的做法。为了找到这些做法，我们可以使用以下工具。 浏览器开发工具让我们看看用于CSS检查的Chrome 开发工具。 如果您喜欢手动检查CSS代码，可以使用Inspect工具。通过使用它，我们可以看到应用到特定元素的CSS代码。使用“检查箭头”，我们甚至可以看到关于颜色、字体、大小和可访问性的更多详细信息。 CSS Overview检查 CSS 是非常基础的，一切都需要手动完成。让我们看看一些更高级的 DevTools 功能。 CSS Overview就是其中之一。要启用 CSS Overview工具，请转到“设置”，单击“实验”，然后启用“CSS Overview”选项。要打开 CSS Overview面板，您可以使用 CMD+Shift+P 快捷键，输入“CSS Overview”，然后选择“显示 CSS Overview”。这个工具总结了 CSS 属性，如颜色、字体、对比度、未使用的声明和媒体查询。我通常使用这个工具来简单判断CSS代码的好坏。例如，如果有“50 级灰度”或太多的排版定义，这意味着风格指南没有得到遵循。 Coverage panel覆盖面板覆盖率工具显示页面上使用的代码量和百分比。要查看它，可以使用 CMD+Shift+P 快捷键，键入“coverage”，选择“Show Coverage”，然后单击“refresh”图标。 也可以通过在 URL 过滤器输入中键入“.css”来仅过滤 CSS 文件。我通常使用这个工具来了解网站使用的技术。例如，如果我看到覆盖率非常高，我可以假设 CSS 文件是为每个页面单独生成的。它可能不是关键数据，但有时它有助于理解网站的缓存策略。 Rendering Panel渲染面板是另一个有用的工具。要打开渲染面板，再次使用 CMD+Shift+P，这次输入“rendering”，然后选择“Show Rendering”选项。这个工具有很多选项，但我最喜欢的是： Paint flashing — 在发生重绘事件时显示绿色矩形。我用它来识别渲染时间过长的区域。 Layout Shift Regions — 当布局移动发生时 显示蓝色矩形。为了充分利用这些选项，我通常在“网络”选项卡下设置“慢速 3G”预设。我有时会录制我的屏幕，然后放慢视频速度以找到布局变化。 其他选项可能更有助于调试问题，例如模拟和禁用各种功能、强制使用首选颜色方案功能或打印介质类型以及禁用本地字体。 Performance Monitor性能监视器另一个用于检查性能 CSS 代码的工具是性能监视器。要启用它，再次使用 CMD+Shift+P，键入“performance monitor”，然后选择“显示性能监视器”选项。我通常使用这个工具来查看在与页面交互时或动画发生时触发了多少重新计算和布局。 Perfomance panel“性能”面板显示页面加载期间所有浏览器事件的详细视图。要启用性能工具，请执行 CMD+Shift+P，键入“性能”，选择“显示性能”，然后单击“重新加载”图标。我通常启用“屏幕截图”和“Web Vitals”选项。对我来说最有趣的指标是 First Paint、First Contentful Paint、Layout Shifts 和 Largest Contentful Paint。还有一个饼图显示绘画和渲染时间。 总结CSS无处不在，我们需要把它视为每个项目的一等公民。别人怎么看你的CSS并不重要，重要的是你怎么看它。如果你的CSS井然有序并且编写良好，那么您将花费更少的时间调试它，从而得以花更多的时间开发新功能。在理想的世界中，我们会教育每个人写好的CSS，但这需要时间。 让今天成为你开始关心CSS代码的日子。 我知道不是每个人都喜欢检查CSS。但是，如果在这些工具上运行代码，并试图改进CSS代码库的哪怕一部分，那么本文就完成了它的工作。 如果你知道任何其他工具，请在评论中告诉我。","categories":[],"tags":[{"name":"CSS, Audit","slug":"CSS-Audit","permalink":"http://yesihao.com/tags/CSS-Audit/"}]},{"title":"Azure DevOps自动化部署React应用到Azure App Service","slug":"Azure DevOps自动化部署React应用到Azure App Service","date":"2021-06-28T16:15:33.000Z","updated":"2021-07-05T09:36:26.763Z","comments":true,"path":"2021/06/29/Azure DevOps自动化部署React应用到Azure App Service/","link":"","permalink":"http://yesihao.com/2021/06/29/Azure%20DevOps%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2React%E5%BA%94%E7%94%A8%E5%88%B0Azure%20App%20Service/","excerpt":"","text":"前言Azure DevOps 提供了项目管理和源代码管理的功能，它的自动化构建和发布可以让我们专注于业务逻辑，省去了一些CI/CD的繁杂琐事。 根据 Azure 的官方文档， Microsoft Azure 具有充分的自由和灵活性，可以随时随地生成、管理和部署应用程序，帮助用户实现目标。使用你首选的语言、框架和基础结构（甚至可使用你自己的数据中心和其他云）解决大大小小的难题。 本文将介绍如何使用Azure DevOps创建React应用的构建和发布管道部署到 Azure App Service，快速上手Azure DevOps自动化部署 创建应用服务要部署 React 应用，首先需要在 Azure 上创建应用服务。顾名思义，应用程序服务（Azure App Service）是用于构建、部署和扩展 Web 应用程序的平台。 以下是步骤： 如果尚未在 Azure 上创建帐户，则可以选择免费帐户。 对于订阅，请选择您的免费订阅。为此应用程序创建一个新的 Resource Group。本文使用名为 react-example-deploy 的资源组。选择 Node 10.14 作为 Runtime Stack，选择 Windows 作为 Operating System。最后，请选择离您最近的地区或保持默认。 点击创建几分钟后，您的新应用服务将上线，您将看到这样的消息。你可以访问 {AppServiceName}.azurewebsites.net 来查看它的实际效果。现在是一个磨人页面，之后 React 应用程序将部署在同一个 URL 上。 创建应用服务在这里，我们将使用 Azure DevOps 在我们的应用程序中简化持续集成和持续部署。 创建 Azure DevOps 组织如果你已经创建了 Azure DevOps 组织，请随意跳过。以下是创建 Azure DevOps 组织的步骤： 登录到 Azure DevOps. 点击 New organization. 你会被问到是否继续. 选择 继续. 然后您将被要求为您的组织提供一个唯一的名称。输入一个唯一的名称并点击继续。本文使用名为 ReactExampleDeploy 的组织。反应示例部署 您的组织现已创建，可以通过 https://dev.azure.com/{yourorganization} 访问，其中 yourorganization 是您组织的名称。 Creating a Project创建项目在 Azure DevOps 组织仪表板上，创建一个新项目。为您的项目指定一个唯一名称，然后点击创建项目 推动 React 项目您现在将 React 应用程序从您的本地机器推送到您刚刚通过命令行创建的项目。 在您的应用程序的根目录中，运行以下命令。 123git initgit add .git commit -m &quot;Initial Commit&quot; bash 在您的项目仪表板上，转到 Repos。复制从命令行推送现有存储库下的代码并在命令行中运行相同的代码。可能会要求您登录 Azure 帐户以继续操作。把代码push到仓库。 运行此命令后，您可以在 Repos → Files 下看到您的 React 项目。 现在你已将应用推送到 Azure DevOps 项目，下一步是创建用于构建工件的管道和用于部署 React 应用的发布管道。 创建构建工件管道根据 Azure 的文档，“您可以使用 Azure Pipelines运行构建、执行测试并将代码（发布）自动部署到各种开发和生产环境。” 以下是创建构建工件管道的步骤。 单击 Pipelines 选项卡然后单击Create Pipeline. 当被问到“你的代码在哪里？”时，选择使用经典编辑器选项。 选择 Azure Repos Git 作为源，将其他所有内容保留为默认值，然后点击Continue. 当要求提供模板时，选择Empty job. 单击 + 号 搜索“npm”并添加两次 npm 任务。 你可能会问，为什么要两次？由于此任务用于node包，因此您需要另一个用于构建项目的任务；不存在默认任务，因此您需要为此创建自定义任务。 点击第二个npm任务，配置如下。 将显示名称更改为 npm run build. 将命令更改为自定义. 在命令和参数中添加运行构建 现在，搜索发布构建工件并将其添加到代理作业 1。 单击 Publish build artifacts 然后修改 Path to publish为 build. 转到触发器选项卡并选择启用持续集成。您可以将其他所有内容保留为默认值。 最后，单击 Save &amp; queue 并再次点击 Save &amp; queue。 在运行管道模式中，将所有内容保留为默认值，然后点击保存并运行。 几分钟后，管道将成功完成运行。您可以在 Pipelines 选项卡下检查以验证它。 创建发布管道发布管道将部署在上一节中构建的工件。 以下是创建发布管道的步骤： 转到Pipelines** → Releases 然后单击 New pipeline. 选择Azure App Service Deployment 然后点击 Apply. 您将被要求为Stage命名。进入 Production 并关闭模态。 现在点击 Add an artifact. 对于 Source，选择您在上一节中创建的管道，即 React Deploy Example-CI。将其他所有内容保留为默认值，然后点击添加。 要配置持续部署，请单击 Artifacts 中的闪电图标。 启用第一个禁用选项，在 Build 分支中输入 master，然后关闭模态框。 在 Stages下面 点击 1 job, 1 task . 会弹出配置 Deploy Azure App Service. 根据您的订阅选择 Azure 订阅。您可能需要单击授权并授权订阅。 点击 Deploy Azure App Service, 然后在 Package or folder 输入: 1$(System.DefaultWorkingDirectory)/_React Deploy Example-CI/drop 最后点击保存 Leave the modal that appears at default and hit OK. 现在，单击 Create release，它将出现在 Save 按钮的右侧。 创建发布 几分钟后，您的应用程序将部署在 {yourappservicename}.azurewebsites.net。 由于您已经配置了 CI/CD，您可以在本地机器上更新应用程序并将提交推送到 repo，这将触发新版本，并且您的 React 应用程序将被更新。 总结在本文中，我们讨论了如何使用 CI/CD 将 React 应用程序部署到 Azure App Service 的过程。 下一步，可以去尝试探索 Azure 提供的不同功能。 以下是一些相关文档。 Azure App Service Azure Pipelines","categories":[],"tags":[{"name":"DevOps, Azure, Azure DevOps, React, Azure App Service","slug":"DevOps-Azure-Azure-DevOps-React-Azure-App-Service","permalink":"http://yesihao.com/tags/DevOps-Azure-Azure-DevOps-React-Azure-App-Service/"}]},{"title":"React Portals","slug":"React Portals","date":"2021-05-30T12:55:16.000Z","updated":"2021-05-31T03:56:17.197Z","comments":true,"path":"2021/05/30/React Portals/","link":"","permalink":"http://yesihao.com/2021/05/30/React%20Portals/","excerpt":"","text":"前言什么是Portals？如何以及何时使用它React v16 引入了一个称为Portals的新功能。 Portals 提供了一种快速简便的方法来将子组件渲染到存在于父组件的 DOM 层次结构之外的 DOM 节点中。 React 在单个 DOM 节点下渲染整个应用程序 - 应用程序根（root）。但是如果你想在根 DOM 节点之外渲染子节点怎么办？那是你使用Portals的时候。比如当父元素具有样式（如 z-index 将其推到页面的最前面或overflow: hidden）你又希望子元素在视觉上显示在其容器顶部时。 它是如何工作的Portals可以位于 DOM 树中的任何位置，它在其他方面的行为都像一个普通的 React 子节点。无论子节点是否是Portals，诸如上下文之类的功能都完全相同，因为无论在 DOM 树中的位置如何，Portals仍然存在于 React 树中。这包括事件冒泡。即使那些元素不是DOM树中的祖先，从Portals内部触发的事件也将传播到包含React的树中的祖先。 用法我建议它创建一个组件，然后在每次需要时使用。首先，我们需要在 index.html 中创建一个 DOM 元素（就像我们为附加应用程序而创建的根元素），这是所有Portals组件将被挂载的地方。 12&lt;div id=&quot;portal-components&quot;&gt;&lt;/div&gt; &lt;div id=&quot;root&quot;&gt; 然后创建Portal组件 12345678910111213141516171819202122232425262728import &#123; PureComponent &#125; from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;const rootElement = document.getElementById(&#x27;portal-components&#x27;)class Portal extends PureComponent &#123; constructor(props) &#123; super(props) this.el = document.createElement(&#x27;div&#x27;) &#125; componentDidMount() &#123; rootElement.appendChild(this.el) &#125; componentWillUnmount() &#123; rootElement.removeChild(this.el) &#125; render() &#123; return ReactDOM.createPortal( this.props.children, this.el ) &#125;&#125;export default Portal 最后这样使用它 123&lt;Portal&gt; &#123;Everithing here is going to be attachaded outside the root DOM node&#125;&lt;/Portal&gt; 注意在使用Portals的时候，所有在组件中被渲染的子元素都会相对与屏幕绝对定位，我建议使用css：position: fixed来调整位置。","categories":[],"tags":[{"name":"React, React Portals","slug":"React-React-Portals","permalink":"http://yesihao.com/tags/React-React-Portals/"}]},{"title":"React实现计算属性的正确方式","slug":"React实现计算属性的正确方式","date":"2021-04-21T14:12:41.000Z","updated":"2021-05-30T14:50:34.412Z","comments":true,"path":"2021/04/21/React实现计算属性的正确方式/","link":"","permalink":"http://yesihao.com/2021/04/21/React%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E5%BC%8F/","excerpt":"","text":"前言React没有像其他框架比如（Ember、Vue 等）那样开箱即用的计算属性，所以我们如何以正确的方式实现这个功能呢？最常见的做法是如果是类组件，在 render 方法中“计算”，或者是函数组件就是在主体中。 问题每次渲染都会进行计算，这意味着即使需要计算的值没有改变，也会生成一个新变量。另外，如果我们将它作为 prop 传递给子组件并且不是原始类型（字符串、数字或布尔值），则子组件将重新渲染，因为它认为这是一个新值，这可能会导致性能问题。 解决方案如果参数没有改变，将计算提取到一个函数并使用记忆化来防止被重新初始化，如果我们在做大量数据等昂贵的计算，这会给我们带来性能上的提升。 例子类组件 12345678910111213141516171819import React from &#x27;react&#x27;import memoize from &#x27;lodash/memoize&#x27;import MenuItem from &#x27;./MenuItem&#x27;class RenderSuggestion extends React.Component &#123; renderSuggestionStyles = (suggestionValue) =&gt; (&#123; pointerEvents: suggestionValue ? &#x27;all&#x27; : &#x27;none&#x27; &#125;) renderSuggestionStylesMemo = memoize(this.renderSuggestionStyles) render()&#123; const &#123; suggestion, ...other &#125; = this.props return ( &lt;MenuItem &#123;...other&#125; style=&#123;this.renderSuggestionStylesMemo(suggestion.value + 1)&#125; /&gt; ) &#125;&#125; 函数组件 123456789101112131415import React from &#x27;react&#x27;import memoize from &#x27;lodash/memoize&#x27;import MenuItem from &#x27;./MenuItem&#x27;const renderSuggestionStyles = suggestionValue =&gt; (&#123; pointerEvents: suggestionValue ? &#x27;all&#x27; : &#x27;none&#x27; &#125;)const renderSuggestionStylesMemo = memoize(renderSuggestionStyles)function RenderSuggestion(&#123; suggestion, ...other &#125;) &#123; return ( &lt;MenuItem &#123;...other&#125; style=&#123;renderSuggestionStylesMemo(suggestion.value + 1)&#125; /&gt; )&#125; 在这里，如果我们不以正确的方式（没有记忆化）使用计算属性，则当道具更改时，子组件（MenuItem）将不必要地重新渲染。 Reselect解决此问题的另一种很酷的方法是使用 reselect 1234567891011121314151617181920import React from &#x27;react&#x27;import &#123; createSelector &#125; from &quot;reselect&quot;;import MenuItem from &#x27;./MenuItem&#x27;class RenderSuggestion extends React.Component &#123; renderSuggestionStyles = createSelector( (suggestionValue) =&gt; (&#123; pointerEvents: suggestionValue ? &#x27;all&#x27; : &#x27;none&#x27; &#125;) ) render()&#123; const &#123; suggestion, ...other &#125; = this.props return ( &lt;MenuItem &#123;...other&#125; style=&#123;this.renderSuggestionStyles(suggestion.value + 1)&#125; /&gt; ) &#125;&#125;","categories":[],"tags":[{"name":"React, Computed","slug":"React-Computed","permalink":"http://yesihao.com/tags/React-Computed/"}]},{"title":"iOS输入框自动放大，如何解决？","slug":"iOS输入框自动放大，如何解决？","date":"2021-03-11T11:32:11.000Z","updated":"2021-05-25T15:34:55.504Z","comments":true,"path":"2021/03/11/iOS输入框自动放大，如何解决？/","link":"","permalink":"http://yesihao.com/2021/03/11/iOS%E8%BE%93%E5%85%A5%E6%A1%86%E8%87%AA%E5%8A%A8%E6%94%BE%E5%A4%A7%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F/","excerpt":"","text":"前言在调试iOS表单的时候，发现点击输入框之后，屏幕会随着检点位置自动放大。但是在安卓中是不会的有这个问题的。 解决办法把&lt;input /&gt;的字体大小为16px或更大，则iOS上的Safari将正常聚焦到输入中。但是，当font-size等于或小于15px时，上述问题再次发生。大概是因为Safari认为该字体太小，希望用户看清楚自己在做什么。因此它会放大以帮助你使用辅助功能。所以如果你不想要这个效果，请使用足够大的字体。 总结总的说，我还是喜欢这个功能。它可以帮助人们看清自己在做什么，并且不建议使用超小字体。","categories":[],"tags":[{"name":"iOS, 放大, 表单","slug":"iOS-放大-表单","permalink":"http://yesihao.com/tags/iOS-%E6%94%BE%E5%A4%A7-%E8%A1%A8%E5%8D%95/"}]},{"title":"React.useRef的用法","slug":"React.useRef的用法","date":"2021-02-19T01:02:44.000Z","updated":"2021-05-25T15:35:33.390Z","comments":true,"path":"2021/02/19/React.useRef的用法/","link":"","permalink":"http://yesihao.com/2021/02/19/React.useRef%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"前言React.createRef和React.useRef都可以用来创建可变对象，这个对象包含current属性，可以用来保存和引用一些值，并且修改这个属性不会触发组件更新。接下来聊它们的不同。 useRef vs createRefuseRef仅能用在FunctionComponent，createRef仅能用在ClassComponent。首先hooks不能用在ClassCompnent中, createRef在FunctionComponent是无效的，因为FunctionComponent每次更新createRef都会重新初始化，所以ref会不断改变，看下面代码 12345function App() &#123; // 错误用法，ref.current永远是null const ref = React.createRef(); return &lt;div ref=&#123;ref&#125; /&gt;;&#125; useRef的用法 1234567function App() &#123; // ref.current 可以保存div的dom实例 const ref = React.useRef(); return &lt;div&gt; &lt;div ref=&#123;ref&#125;&gt;hello world&lt;/div&gt; &lt;/div&gt;&#125; 也可以使用callback ref保存dom实例。但是这个方法会有个小问题，官方文档也有说明。 1234567class App extends React.Component &#123; render() &#123; return ( &lt;input type=&quot;text&quot; ref=&#123;el =&gt; this.inputRef = el&#125; /&gt; ) &#125;&#125; 总结useRef有两种用例： 直接访问DOM节点以强制执行DOM操作 在组件实例的整个生命周期中，在所有渲染器中保持一个值与useEffect，useState和useCallback结合使用时，可以保留以前的状态。 最后，不要滥用 Ref，Mutable 引用越多，对 React 来说可维护性一般会越差。","categories":[],"tags":[{"name":"React, createRef, useRef","slug":"React-createRef-useRef","permalink":"http://yesihao.com/tags/React-createRef-useRef/"}]},{"title":"在React项目中使用Font-Awesome图标","slug":"在React项目中使用Font-Awesome图标","date":"2021-01-12T12:22:11.000Z","updated":"2021-05-25T15:38:08.054Z","comments":true,"path":"2021/01/12/在React项目中使用Font-Awesome图标/","link":"","permalink":"http://yesihao.com/2021/01/12/%E5%9C%A8React%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Font-Awesome%E5%9B%BE%E6%A0%87/","excerpt":"","text":"前言如果你曾经不得不在网页上显示某种图标，那你和可能就使用或看过Font Awesome。 Font Awesome是一个很棒的图标库，它还提供了一个不错的React组件，所以在React程序中使用非常简单。 准备为了快速搭建项目，我们使用create-react-app。 安装 Font-Awesome真棒字体启动React应用程序后，我们需要安装Font Awesome提供的库： 123456＃SVG渲染库npm我 --save fortawesome / fontawesome-svg-core＃Font Awesome提供的图标集npm install --save fortawesome / free-solid-svg-icons＃我们将使用的实际React组件npm install --save fortawesome / react-fontawesome 这将安装所有必要的部件，接下来就可以使用了。还可以安装许多其他样式不同的图标集，包括Pro图标。这里我们只使用纯风格的免费图标。 注意：要使用Pro图标，需要一个付费的Pro帐户。 使用图标现在，让我们打开App.js文件。它只包含JSX create-react-app提供的样板。我们先删除标头标签中的所有内容，保留有些样式，以便后续开发。 我们将需要导入我们安装的FontAwesomeIcon组件和一个SVG Icon进行渲染，然后使用fa-rocket图标。 SVG图案一般用于在图图形对象内部定义形状，创建一个新形状并用图案填充它。一个SVG元素或是位图图像，都可以通过元素在x轴或y轴方向以固定的间隔平铺。下面会展示几个的简单SVG形状的。这个列表可能会随着时间的推移而增长，但是要想拥有一个全面的集合，可以在这基础上创造新图案。 123456789101112131415import &#x27;./App.css&#x27;;// Font Awesome Importsimport &#123; faRocket &#125; from &#x27;@fortawesome/free-solid-svg-icons&#x27;;import &#123; FontAwesomeIcon &#125; from &#x27;@fortawesome/react-fontawesome&#x27;;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;FontAwesomeIcon icon=&#123;faRocket&#125; /&gt; &lt;/div&gt; );&#125;export default App; 设置图标库如果我们要使用大量图标，要怎么做呢？其实我们不须要在要使用它们的任何地方重新导入，Font Awesome提供了一种创建图标库的方法，该图标库在导入后可在全球范围内使用。要进行设置，我们首先创建一个名为fontawesome.js的新文件。我们将库设置添加到此文件中。 12345678910// Import the libraryimport &#123; library &#125; from &#x27;@fortawesome/fontawesome-svg-core&#x27;// Import whichever icons you want to useimport &#123; faRocket, faHome &#125; from &#x27;@fortawesome/free-solid-svg-icons&#x27;// Add the icons to your librarylibrary.add( faRocket, faHome) 注意：你也可以从“ @ fortawesome / free-solid-svg-icons”中将*作为图标导入； 并将它们映射到您的库中以获取所有图标，但是打包之后非常大！ 最好只选择需要的那些。 这就是库的所有设置！唯一改变的是渲染组件时我们如何指定图标。 让我们看下App.js文件 123456789101112131415161718import &#x27;./App.css&#x27;;// NOTICE we don&#x27;t need to import the individual icons!import &#123; FontAwesomeIcon &#125; from &#x27;@fortawesome/react-fontawesome&#x27;;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;FontAwesomeIcon icon=&#123;[&#x27;fa&#x27;, &#x27;rocket&#x27;]&#125; /&gt; &lt;br/&gt; &lt;FontAwesomeIcon icon=&#123;[&#x27;fa&#x27;, &#x27;home&#x27;]&#125; /&gt; &lt;/header&gt; &lt;/div&gt; );&#125;export default App; 总结现在，你可以在整个应用中随意使用图标了。 我强烈建议配置Font Awesome文档中介绍的其他选项和属性去配置图标库，然后再使用这些图标！","categories":[],"tags":[{"name":"React, Font-Awesome","slug":"React-Font-Awesome","permalink":"http://yesihao.com/tags/React-Font-Awesome/"}]},{"title":"”区号“输入框的正确打开方式","slug":"”区号“输入框的正确打开方式","date":"2020-12-23T15:02:19.000Z","updated":"2021-02-07T15:07:52.025Z","comments":true,"path":"2020/12/23/”区号“输入框的正确打开方式/","link":"","permalink":"http://yesihao.com/2020/12/23/%E2%80%9D%E5%8C%BA%E5%8F%B7%E2%80%9C%E8%BE%93%E5%85%A5%E6%A1%86%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/","excerpt":"","text":"前言在编写表单时经常会出现区号字段，因为区号是一串数字，所以开始想到要用&lt;input type=&quot;number&quot;&gt;，但是可能会有其他问题。 用法1&lt;input type=&quot;number&quot;&gt; 之所以会使用*type=”number”，是这样可以利用浏览器的自动校验，并在移动设备上触发用户体验更好的更有用的基于数字的键盘。但是这样的问题是，对于区号来说type=”number”*是有问题的，因为区号可以有（例如，浙江杭州0571）。 所以可以使用的。 1&lt;input type=&quot;text&quot; inputmode=&quot;numeric&quot; pattern=&quot;^/d$&quot;&gt; 有人提到试图劫持type=“tel”，但这有其缺点，例如拒绝正确格式化的4位数区号。 因此，虽然区号看起来像数字，但最好还是将其视为字符串。","categories":[],"tags":[{"name":"input, html","slug":"input-html","permalink":"http://yesihao.com/tags/input-html/"}]},{"title":"SVG图案填充-Pattern","slug":"SVG图案填充-Pattern","date":"2020-11-13T15:42:31.000Z","updated":"2021-02-03T13:05:45.861Z","comments":true,"path":"2020/11/13/SVG图案填充-Pattern/","link":"","permalink":"http://yesihao.com/2020/11/13/SVG%E5%9B%BE%E6%A1%88%E5%A1%AB%E5%85%85-Pattern/","excerpt":"","text":"前言SVG图案一般用于在图图形对象内部定义形状，创建一个新形状并用图案填充它。一个SVG元素或是位图图像，都可以通过元素在x轴或y轴方向以固定的间隔平铺。下面会展示几个的简单SVG形状的。这个列表可能会随着时间的推移而增长，但是要想拥有一个全面的集合，可以在这基础上创造新图案。 圆形图案12345678910111213141516&lt;svg width=&quot;100%&quot; height=&quot;100%&quot;&gt; &lt;mask maskUnits=&quot;userSpaceOnUse&quot; id=&quot;fade&quot;&gt; &lt;linearGradient id=&quot;gradient&quot; x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;0&quot; y2=&quot;100%&quot;&gt; &lt;stop offset=&quot;0&quot; style=&quot;stop-color: #FFFFFF&quot;&gt;&lt;/stop&gt; &lt;stop offset=&quot;1&quot; style=&quot;stop-color: #000000&quot;&gt;&lt;/stop&gt; &lt;/linearGradient&gt; &lt;rect fill=&quot;url(#gradient)&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/rect&gt; &lt;/mask&gt; &lt;pattern id=&quot;pattern-circles&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;40&quot; height=&quot;40&quot; patternUnits=&quot;userSpaceOnUse&quot;&gt; &lt;circle mask=&quot;url(#fade)&quot; cx=&quot;20&quot; cy=&quot;20&quot; r=&quot;20&quot;&gt;&lt;/circle&gt; &lt;/pattern&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;url(#pattern-circles)&quot;&gt;&lt;/rect&gt;&lt;/svg&gt; 棋盘图案1234567891011&lt;svg width=&quot;100%&quot; height=&quot;100%&quot;&gt; &lt;pattern id=&quot;pattern-checkers&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;200&quot; patternUnits=&quot;userSpaceOnUse&quot;&gt; &lt;rect class=&quot;checker&quot; x=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; y=&quot;0&quot;&gt;&lt;/rect&gt; &lt;rect class=&quot;checker&quot; x=&quot;100&quot; width=&quot;100&quot; height=&quot;100&quot; y=&quot;100&quot;&gt;&lt;/rect&gt; &lt;/pattern&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;url(#pattern-checkers)&quot;&gt;&lt;/rect&gt;&lt;/svg&gt; 六角形图案1234567891011121314&lt;svg width=&quot;100%&quot; height=&quot;100%&quot;&gt; &lt;pattern id=&quot;pattern-hex&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;112&quot; height=&quot;190&quot; patternUnits=&quot;userSpaceOnUse&quot; viewBox=&quot;56 -254 112 190&quot;&gt; &lt;g id=&quot;hexagon&quot;&gt; &lt;path d=&quot;M168-127.1c0.5,0,1,0.1,1.3,0.3l53.4,30.5c0.7,0.4,1.3,1.4,1.3,2.2v61c0,0.8-0.6,1.8-1.3,2.2L169.3-0.3 c-0.7,0.4-1.9,0.4-2.6,0l-53.4-30.5c-0.7-0.4-1.3-1.4-1.3-2.2v-61c0-0.8,0.6-1.8,1.3-2.2l53.4-30.5C167-127,167.5-127.1,168-127.1 L168-127.1z&quot;&gt;&lt;/path&gt; &lt;path d=&quot;M112-222.5c0.5,0,1,0.1,1.3,0.3l53.4,30.5c0.7,0.4,1.3,1.4,1.3,2.2v61c0,0.8-0.6,1.8-1.3,2.2l-53.4,30.5 c-0.7,0.4-1.9,0.4-2.6,0l-53.4-30.5c-0.7-0.4-1.3-1.4-1.3-2.2v-61c0-0.8,0.6-1.8,1.3-2.2l53.4-30.5 C111-222.4,111.5-222.5,112-222.5L112-222.5z&quot;&gt;&lt;/path&gt; &lt;path d=&quot;M168-317.8c0.5,0,1,0.1,1.3,0.3l53.4,30.5c0.7,0.4,1.3,1.4,1.3,2.2v61c0,0.8-0.6,1.8-1.3,2.2L169.3-191 c-0.7,0.4-1.9,0.4-2.6,0l-53.4-30.5c-0.7-0.4-1.3-1.4-1.3-2.2v-61c0-0.8,0.6-1.8,1.3-2.2l53.4-30.5 C167-317.7,167.5-317.8,168-317.8L168-317.8z&quot;&gt;&lt;/path&gt; &lt;/g&gt; &lt;/pattern&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;url(#pattern-hex)&quot;&gt;&lt;/rect&gt;&lt;/svg&gt; 立方体图案1234567891011121314151617&lt;svg width=&quot;100%&quot; height=&quot;100%&quot;&gt; &lt;pattern id=&quot;pattern-cubes&quot; x=&quot;0&quot; y=&quot;126&quot; patternUnits=&quot;userSpaceOnUse&quot; width=&quot;126&quot; height=&quot;200&quot; viewBox=&quot;0 0 10 16&quot;&gt; &lt;g id=&quot;cube&quot;&gt; &lt;path class=&quot;left-shade&quot; d=&quot;M0 0l5 3v5l-5 -3z&quot;&gt;&lt;/path&gt; &lt;path class=&quot;right-shade&quot; d=&quot;M10 0l-5 3v5l5 -3&quot;&gt;&lt;/path&gt; &lt;/g&gt; &lt;use x=&quot;5&quot; y=&quot;8&quot; xlink:href=&quot;#cube&quot;&gt;&lt;/use&gt; &lt;use x=&quot;-5&quot; y=&quot;8&quot; xlink:href=&quot;#cube&quot;&gt;&lt;/use&gt; &lt;/pattern&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;url(#pattern-cubes)&quot;&gt;&lt;/rect&gt;&lt;/svg&gt;","categories":[],"tags":[{"name":"svg, xml","slug":"svg-xml","permalink":"http://yesihao.com/tags/svg-xml/"}]},{"title":"classList() API简介","slug":"classList() API简介","date":"2020-10-06T05:02:12.000Z","updated":"2021-02-02T13:30:26.705Z","comments":true,"path":"2020/10/06/classList() API简介/","link":"","permalink":"http://yesihao.com/2020/10/06/classList()%20API%E7%AE%80%E4%BB%8B/","excerpt":"","text":"前言之前为了操纵DOM元素class列表，经常会引入jQuery之类的库。其实html5的classList API还是非常方便的，而且兼容性也不错。 API用法假设我们有这样一个DOM元素 1&lt;div id=&quot;el&quot;&gt;&lt;/div&gt; 获取DOM元素 1const el = document.querySelector(&quot;#el&quot;); 然后你可以用classList方法操纵该元素上所有的类 12345678910111213141516171819202122232425262728293031323334353637383940414243// 添加一个类el.classList.add(&quot;open&quot;);// 添加多个类el.classList.add(&quot;this&quot;, &quot;little&quot;, &quot;piggy&quot;);let classes = [&quot;is-message&quot;, &quot;is-warning&quot;];el.classList.add(...classes);// 删除一个类el.classList.remove(&quot;open&quot;);// 删除多个类el.classList.remove(&quot;this&quot;, &quot;little&quot;, &quot;piggy&quot;);// 遍历每个类el.classList.forEach(className =&gt; &#123; // 不要使用“class”作为变量名，因为这是保留字 console.log(className);&#125;);for (let className of $0.classList) &#123; console.log(className);&#125;el.classList.length; // 获取类的个数// 替换类el.classList.replace(&quot;is-big&quot;, &quot;is-small&quot;);// 切换一个类（如果存在，则将其删除，如果不存在，则将其添加）el.classList.toggle(&quot;open&quot;);// 删除类el.classList.toggle(&quot;open&quot;, false);// 增加类el.classList.toggle(&quot;open&quot;, true);// 查看各个类是否存在el.classList.contains(&quot;open&quot;);// 按顺序查看每个类：&lt;div class=&quot;hot dog&quot;&gt;el.classList.item(0); // hotel.classList.item(1); // dogel.classList.item(2); // nullel.classList[1]; // dog 兼容性","categories":[],"tags":[{"name":"classList, javascript","slug":"classList-javascript","permalink":"http://yesihao.com/tags/classList-javascript/"}]},{"title":"层叠纸效果","slug":"层叠纸效果","date":"2020-09-23T14:12:46.000Z","updated":"2021-02-02T13:11:07.319Z","comments":true,"path":"2020/09/23/层叠纸效果/","link":"","permalink":"http://yesihao.com/2020/09/23/%E5%B1%82%E5%8F%A0%E7%BA%B8%E6%95%88%E6%9E%9C/","excerpt":"","text":"前言现在一种流行的设计是创建一个容器，并在里面堆叠其他纸，然后添加分层或三维样式。我们可以使用CSS来完成这个效果，而且还可以做成多种类型的堆叠纸设计。接下来我们将展示3个不同效果。 底部垂直层叠纸这里的想法是，我们的内容容器是顶层纸，并且更多的纸堆在其下方，并且其边缘显示在顶层纸的底部。 1&lt;div class=&quot;paper&quot;&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132.paper &#123; background-color: #fff; position: relative; padding: 30px;&#125;.paper,.paper::before,.paper::after &#123; box-shadow: 2px 1px 1px rgba(0,0,0,0.15);&#125;.paper::before,.paper::after &#123; content: &quot;&quot;; position: absolute; width: 100%; height: 100%; background-color: #eee;&#125;.paper::before &#123; left: 7px; top: 5px; z-index: -1;&#125;.paper::after &#123; left: 12px; top: 10px; z-index: -2;&#125; 对角层叠纸这是一种效果使用的方法略有不同，我们使用::before和::after伪元素来创建其他纸张，而不是前面的示例中使用的box-shadow属性。 123456789101112131415161718192021222324252627282930313233.paper &#123; background-color: #fff; position: relative; padding: 30px;&#125;.paper,.paper::before,.paper::after &#123; box-shadow: 2px 1px 1px rgba(0,0,0,0.15);&#125;.paper::before,.paper::after &#123; content: &quot;&quot;; position: absolute; width: 100%; height: 100%; background-color: #eee;&#125;.paper::before &#123; left: 7px; top: 5px; z-index: -1;&#125;.paper::after &#123; left: 12px; top: 10px; z-index: -2;&#125; 混乱层叠纸我们可以使用与上一个示例相同的伪元素技术，使纸页错开以创建的凌乱形态，这里会使用transform属性旋转底层纸页。（注意transform属性浏览器兼容性）。 1234567891011121314151617181920212223242526272829303132333435.paper &#123; background: #fff; padding: 30px; position: relative;&#125;.paper,.paper::before,.paper::after &#123; box-shadow: 1px 1px 1px rgba(0,0,0,0.25); border: 1px solid #bbb;&#125;.paper::before,.paper::after &#123; content: &quot;&quot;; position: absolute; height: 95%; width: 99%; background-color: #eee;&#125;.paper::before &#123; right: 15px; top: 0; transform: rotate(-1deg); z-index: -1;&#125;.paper::after &#123; top: 5px; right: -5px; transform: rotate(1deg); z-index: -2;&#125;","categories":[],"tags":[{"name":"CSS, 样式","slug":"CSS-样式","permalink":"http://yesihao.com/tags/CSS-%E6%A0%B7%E5%BC%8F/"}]},{"title":"使用IntersectionObserver检查页面是否滚动到特定点","slug":"使用IntersectionObserver检查页面是否滚动到特定点","date":"2020-08-29T14:19:41.000Z","updated":"2020-09-15T13:20:39.267Z","comments":true,"path":"2020/08/29/使用IntersectionObserver检查页面是否滚动到特定点/","link":"","permalink":"http://yesihao.com/2020/08/29/%E4%BD%BF%E7%94%A8IntersectionObserver%E6%A3%80%E6%9F%A5%E9%A1%B5%E9%9D%A2%E6%98%AF%E5%90%A6%E6%BB%9A%E5%8A%A8%E5%88%B0%E7%89%B9%E5%AE%9A%E7%82%B9/","excerpt":"","text":"网页滚动就是一个DOM事件。我可以使用window.scrollY随时查看窗口滚动了多远。我可以监听该事件并获取该数值： 123window.addEventListener(&quot;scroll&quot;, () =&gt; &#123; console.log(window.scrollY)&#125;); 假设我想知道用户是否向下滚动了100px或更多，我可以通过判断window.Y &gt; 100来进行测试。这里，我将结果log出来： 1234567window.addEventListener(&quot;scroll&quot;, () =&gt; &#123; if (window.scrollY &lt; 100) &#123; console.log(&quot;Not past 100px&quot;); &#125; else &#123; console.log(&quot;Past 100px!&quot;); &#125;&#125;); 1&lt;div id=&quot;pixel-to-watch&quot;&gt;&lt;/div&gt; 虽然它简单，易于理解且有效，但这是一个坏主意。因为这有点反模式，这种事件会发生很多次。当用户向下滚动页面时，它可以轻松触发几十，数百或数千次。每次这样做，我们都必须在JavaScript的单线程上运行。这意味着需要更多的时间来解决滚动问题，而花费较少的时间进行其他重要的事情。 有很多方法可以减少这种强度，并且自然地，这是一个非常好的主意。Throttling和Debouncing是JavaScript中提高性能的良好模式。其要点是，在它们执行之前，它们阻止执行较大的JavaScript。 不过，还有更好的方法: 1&lt;div id=&quot;pixel-to-watch&quot;&gt;&lt;/div&gt; 1234567#pixel-to-watch &#123; position: absolute; width: 1px; height: 1px; top: 100px; left: 0;&#125; 使用IntersectionObserver: 123456789let observer = new IntersectionObserver(entries =&gt; &#123; console.log(entries); if (entries[0].boundingClientRect.y &lt; 0) &#123; console.log(&quot;Past 100px!&quot;); &#125; else &#123; console.log(&quot;Not past 100px&quot;); &#125;&#125;);observer.observe(document.querySelector(&quot;#pixel-to-watch&quot;));","categories":[],"tags":[{"name":"JavaScript, IntersectionObserver","slug":"JavaScript-IntersectionObserver","permalink":"http://yesihao.com/tags/JavaScript-IntersectionObserver/"}]},{"title":"反向字符串 - JavaScript","slug":"反向字符串 - JavaScript","date":"2020-07-30T10:29:11.000Z","updated":"2021-02-02T10:36:33.168Z","comments":true,"path":"2020/07/30/反向字符串 - JavaScript/","link":"","permalink":"http://yesihao.com/2020/07/30/%E5%8F%8D%E5%90%91%E5%AD%97%E7%AC%A6%E4%B8%B2%20-%20JavaScript/","excerpt":"","text":"前言反向字符串问题是常见的算法问题。我们需要写一个反向字符串的函数，如果将“tom”传递给函数，则返回“mot”。在本文中，我们将考虑针对它的4个JavaScript解决方案。 方法1.使用数组reverse·方法有了Array.reverse() 方法，我们可以轻松地反转数组。 reverse() 方法将数组反转到位。但我们正在处理字符串，这意味着我们必须使用split方法将字符串转换为数组，使用reverse方法将其反向，并使用join方法将其转换回字符串。 这是代码示例。 1234567function reverseString(string) &#123; let array = string.split(&#x27;&#x27;); array.reverse() return array.join(&#x27;&#x27;)&#125; 我们可以使用箭头函数写成一行 1const reverseString = (string) =&gt; string.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;); 方法2.使用For Of循环这是反向转换字符串的经典示例。我们在这里要做的是创建一个空字符串，该字符串将保留反向的string，循环遍历字符串中的每个字符，并将其附加到新字符串的开头。 123456789function reverse(str) &#123; let reverseString = &#x27;&#x27;; for (let character of str) &#123; reverseString = character + reverseString; &#125; return reverseString&#125; 方法3.使用Array.reduce()reduce方法在数组的每个元素上执行reducer函数，从而产生单个输出值。要使用reduce方法，我们需要将字符串转换为数组。接下来，我们使用reduce方法将其转换为字符串。这样，reducer将字符串的每个字符附加到累加值，该累加器值就是反转的字符串。 123456789function reverseString(string) &#123; const array = string.split(&#x27;&#x27;); const reversedString = array.reduce((reversed, character) =&gt; &#123; return character + reversed &#125;, &#x27;&#x27;) return reversedString&#125; 上述函数也可以写成下面的形式 123const reverseString = (string) =&gt; &#123; return string.split(&#x27;&#x27;).reduce((reversed, character) =&gt; character + reversed, &#x27;&#x27;)&#125; 甚至可以写成更短的单行 1const reverseString = (string) =&gt; string.split(&#x27;&#x27;).reduce((rev, char) =&gt; char + rev, &#x27;&#x27;) 方法4.使用递归你熟悉递归的吗？ 递归是一种通过使用调用自身的函数来解决问题的方法。每次函数调用自身时，它将问题减少为子问题。该递归调用继续进行，直到到达无需进一步递归。你可以参考。 首先我们使用string.substring（）方法获取删除字符串中的第一个字符，并将其他字符传递给函数。 然后，将第一个字符添加到return语句中，如下面的代码所示。 1234567function reverse(string)&#123; if(string === &#x27;&#x27;) &#123; return string &#125; else&#123; return reverse(string.substring(1)) + string[0] &#125;&#125; 我们可以使用三元操作符简化上述函数 123function reverse(string) &#123; return string ? reverse(string.substring(1)) + string[0] : string&#125; 总结这样就可以用四种很酷的方法来反转JavaScript中的字符串。扎实的数据结构和算法知识来自许多实践，还有什么更好的方式欢迎留言。","categories":[],"tags":[{"name":"JavaScript, string","slug":"JavaScript-string","permalink":"http://yesihao.com/tags/JavaScript-string/"}]},{"title":"Azure Functions 连接 MongoDB","slug":"Azure Functions 连接 MongoDB","date":"2020-06-22T14:01:36.000Z","updated":"2020-07-13T16:11:26.775Z","comments":true,"path":"2020/06/22/Azure Functions 连接 MongoDB/","link":"","permalink":"http://yesihao.com/2020/06/22/Azure%20Functions%20%E8%BF%9E%E6%8E%A5%20MongoDB/","excerpt":"","text":"前言无服务器架构计算变得越来越流行，但是，当使用无服务器架构来构建后端API时，经常会遇到一些小问题。使用无状态函数是否意味着必须在每次运行该函数时都建立与数据库的新连接？ 其实大多数问题都有解决方法，因此不必每次运行函数时花费额外的时间来连接数据库。所以今天准备写一下关于使用MongoDB驱动程序和mongoose与Azure Functions重复使用数据库连接的文章。本文将完成在Node.js中创建Azure Functions的过程，以及将该函数将连接到MongoDB并在请求之间重用数据库连接。 创建一个简单的Azure函数在之前的文章中已经讲解了如何创建Azure Functions，这里也不再赘述。首先我们在Azure Portal上创建一个Azure Function。![创建好的Azure Function](/images/Azure Functions 连接 MongoDB1.jpg) 安装MongoDB驱动程序接下来让我们将该功能连接到数据库。在Azure Function中添加npm模块与在AWS Lambda的过程非常不同。使用Azure Functions，必须登录到服务器，然后创建package.json，然后运行npm install。对于“无服务器”架构来说，这似乎很奇怪，但是好处就是不必一遍又一遍地捆绑相同的依赖，也不必担心node_modules运行在Lambda对函数大小的限制。 要安装MongoDB Node.js驱动程序，请首先转到.scm.azurewebsites.net，然后单击“调试控制台”-&gt;“ PowerShell”。![PowerShell](/images/Azure Functions 连接 MongoDB2.jpg) 转到D:\\home\\site\\wwwroot目录下，新建名为的package.json文件，增加MongoDB一览，最后保存。![创建好package.json](/images/Azure Functions 连接 MongoDB3.jpg) 执行npm i![执行npm i](/images/Azure Functions 连接 MongoDB4.jpg) 回到Azure Function编辑界面，写入代码。 12345678910111213141516171819202122232425262728293031const mongodb = require(&#x27;mongodb&#x27;);// URI for MongoDB Atlas xxx为省略 https://www.mongodb.com/cloud/atlasconst uri = &#x27;mongodb+srv://xxx.mongodb.net/test&#x27;;module.exports = function (context, req) &#123; context.log(&#x27;Running&#x27;); mongodb.MongoClient.connect(uri, function(error, client) &#123; if (error) &#123; context.log(&#x27;Failed to connect&#x27;); context.res = &#123; status: 500, body: res.stack &#125; return context.done(); &#125; context.log(&#x27;Connected&#x27;); client.db(&#x27;test&#x27;).collection(&#x27;tests&#x27;).find().toArray(function(error, docs) &#123; if (error) &#123; context.log(&#x27;Error running query&#x27;); context.res = &#123; status: 500, body: res.stack &#125; return context.done(); &#125; context.log(&#x27;Success!&#x27;); context.res = &#123; headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;, body: JSON.stringify(&#123; res: docs &#125;) &#125;; context.done(); &#125;); &#125;);&#125;; 重用数据库连接但是每次该函数运行时创建一个新的数据库连接会降低性能。所以与Lambda一样，可以使用Node.js运行时的小技巧来保留调用之间的数据库连接。具体来说，脚本中的全局变量可能在函数调用之间保留，因此，如果向MongoDB客户端添加全局指针，则它将一直保留，直到它被Azure清除它。 123456789101112131415161718192021222324252627282930313233343536373839404142434445const mongodb = require(&#x27;mongodb&#x27;);const uri = &#x27;mongodb+srv://xxx/test&#x27;;// May be retained between function executions depending on whether Azure// cleans up memorylet client = null;module.exports = function (context, req) &#123; context.log(&#x27;Running&#x27;); let hasClient = client != null; if (client == null) &#123; mongodb.MongoClient.connect(uri, function(error, _client) &#123; if (error) &#123; context.log(&#x27;Failed to connect&#x27;); context.res = &#123; status: 500, body: res.stack &#125; return context.done(); &#125; client = _client; context.log(&#x27;Connected&#x27;); query(); &#125;); &#125; else &#123; query(); &#125; function query() &#123; client.db(&#x27;test&#x27;).collection(&#x27;tests&#x27;).find().toArray(function(error, docs) &#123; if (error) &#123; context.log(&#x27;Error running query&#x27;); context.res = &#123; status: 500, body: res.stack &#125; return context.done(); &#125; context.log(&#x27;Success!&#x27;); context.res = &#123; headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;, body: &#x27;Num docs &#x27; + docs.length + &#x27;, reused connection &#x27; + hasClient &#125;; context.done(); &#125;); &#125;&#125;; 第一次运行会创杰数据库连接，第二次运行就会从全局变量中拿到以前的连接。很明显会更快。 最后Azure Functions不需要您捆绑node_modules，而是让您在功能应用程序中的多个功能之间共享node_modules。Azure Functions可以大规模执行代码，而不必担心置备和管理基础虚拟机和操作系统。MongoDB使开发人员能够快速将想法变为现实，而不会影响数据库的工作效率。 Azure平台和MongoDB一起为开发人员提供了一套快速开发的环境。","categories":[],"tags":[{"name":"Serverless, Azure, Azure Function, MongoDB","slug":"Serverless-Azure-Azure-Function-MongoDB","permalink":"http://yesihao.com/tags/Serverless-Azure-Azure-Function-MongoDB/"}]},{"title":"为什么React需要Hooks","slug":"为什么React需要Hooks","date":"2020-05-28T02:24:23.000Z","updated":"2020-06-17T03:15:13.205Z","comments":true,"path":"2020/05/28/为什么React需要Hooks/","link":"","permalink":"http://yesihao.com/2020/05/28/%E4%B8%BA%E4%BB%80%E4%B9%88React%E9%9C%80%E8%A6%81Hooks/","excerpt":"","text":"前言如果你是一个React开发者，那么你经常会听到关于React hooks，也就是所说的钩子的讨论。而对于那些没有使用过React hooks的开发者来说，这只是React内置的函数，它们可以让我们让在functional组件内里做所有可以在class组件内做的事。 但是为什么要使用React hooks呢？ 如果类组件可以完成我们希望它们做的所有事情，比如初始化状态，设置状态，访问组件的生命周期，创建上下文，调用引用等，那么我们为什么要为我们的展示性组件提供一种方法，做同样的事情呢？functional组件有什么特别之处？ 好吧，事实证明，使用钩子为开发人员带来好处的原因有很多。首先是大型组件可能难以使用，在大型项目上工作的开发者们，组件的状态可能会越来愈多，愈来愈复杂，其大小经常会在组件生命周期方法中散布相同或相似的逻辑。第二个是方法重用，重用组件方法（尤其是复杂的逻辑）依赖于设计模式，例如高阶组件或渲染参数，这反过来又需要开发人员重新组织其组件层次结构，并可能导致组件层级混乱。最后，类语法对卡发者和编译器都造成了混淆，并且可能导致React所追求的纯粹的功能设计模式无法实现。 那么钩子如何解决这些问题呢？ 组件大小当涉及到组件的规模，大小时，钩子使用useEffect提取生命周期方法中的许多重复功能，并使用useState初始化，改变状态。例如，一个useEffect挂钩可以完成3种生命周期方法的工作：componentDidMount，componentDidUpdate和componentWillUnmount。通过指定一个可选的依赖项数组，您可以告诉useEffect在指定的状态引用中查找更改，然后再次运行该效果，等效于componentDidUpdate。通过指定一个空的依赖关系数组，您可以告诉useEffect仅运行一次componentDidMount。当从DOM中删除组件时，您需要执行一些数据清除操作（例如清除间隔或阻止api调用），您可以在return语句中为useEffect回调，该语句将在unmount- componentWillUnmount上运行。所有这些工作都可以通过一个useEffect调用来完成，这使其成为解决副作用的强大方法！ 方法复用在应用中其他地方重用组件逻辑时，我们概括这些方案的传统方式是使用渲染道具或HOC（高阶组件）。渲染道具的工作方式是将带有独立JSX的自定义回调作为参数,传递给我们的组件。当我们希望相同的渲染组件的多个实例之间重用时，就可以这样。例如，如果我们想通过一个组件跟踪鼠标的位置，但想对该数据做不同的事情（例如在p标签而不是h1标签中显示位置），则可以通过指定渲染擦输来实现使用定制的JSX。 12&lt;MousePosition render = &#123;position =&gt; &lt;p&gt;&#123;position&#125;&lt;/p&gt;&#125;&gt;&lt;/MousePosition&gt;&lt;MousePosition render = &#123;position =&gt; &lt;h1&gt;&#123;position&#125;&lt;/h1&gt;&#125;&gt;&lt;/MousePosition&gt; HOC（高阶组件）通过创建包装器组件或返回包装器组件的函数来实现，该函数使包装的组件可以访问某些数据或功能。如果多个组件正在执行相似但略有不同的工作，例如从相同来源获取某些数据但使用不同方法，则我们将希望使用此功能。想想Redux的connect（）函数，它将包装好的组件连接到我们的商店。这里可能需要连接多个组件，但是状态和调度方法的需求却有所不同。因此，我们可以向我们的连接HOC提供自定义的mapStateToProps和mapDispatchToProps函数，以为包装的组件提供个性化数据。 1export default connect(mapStateToProps, mapDispatchToProps)(SomeComponent); 尽管这些模式对于类组件非常有效，但它们也有缺点。特别是，它们要求开发人员重写其组件层次结构，并可能导致包装器地狱的第9个循环。 React hooks的替代方法是允许我们的可以调用以自定义hook的形式在各​​个组件之间共享。自定义钩子只是可组合的函数，可以像其他任何函数一样在组件之间导出和共享。可组合的意思是指具有多个部分（例如useState和useEffect调用），将它们组合为可重用模式并将其抽象为自己的单独功能的能力。这种模式在类组件中将是不可能的，因为做诸如获取数据或实例化状态之类的简单操作不能与调用它们的类方法分开。 性能与困惑最后，大家对于类组件的性能其实没有什么担心。在2018年React Conference上，当React Hooks揭幕时，有人指出类组件对于机器和人类都很难理解。由于类语法只是JavaScript原型继承的一种语法糖，因此类的工作方式与其他编程语言不同。React团队注意到在生产环境中最小化类组件的问题，并且在实现热模块重新加载时存在不一致之处。此外，对于开发者，尤其是对那些刚接触类语法的开发者来说，可能很难理解’this’关键字的绑定是如何工作的，或者难以理解其他类的细微差别，例如在构造函数内部调用super（）的目的。 由于React hooks使我们能够在功能组件内部使用所有相同的类组件功能，因此我们能够提高React代码的性能。此外，钩子具有简洁的语法，不仅与React的纯功能设计紧密相关，而且与JavaScript紧密相关。 React在其他基于组件的前端库（如Vue）之间的主要区别之一是它通过JSX和css模块将html，css和JavaScript耦合在一起。这意味着，如果你是JavaScript专家，那么您就是React（提供或获取实现细节）专家，而不是像过去那样依赖Vue在HTML，CSS和JS之间拆分文件的模板结构jQuery和Vanilla JS的DOM处理的概念。 尽管功能组件的性能略有提高，但性能不应成为使用React hooks的主要原因。它也不会在React中添加尚不存在的任何功能。其主要目的只是简单地将功能组件提升到与类组件相同的级别，从而通过更干净，更可维护的代码，更好地在组件之间重用方法以及更简单，更具声明性的使用方式，从而获得更好的DX（开发人员体验）。 话虽这么说，但我有一些同事发现React hooks在概念上不容易掌握，尤其是在了解useEffect，useState或useContext时。例如，很难看到应该如何将生命周期方法中的各种逻辑组合成单个函数调用。因此，最近，有开发者创建了一个称为Hookd的CLI模板工具，以将类组件立即转换为带有钩子的功能组件。 清理代码，理清思路最后，使用React hooks似乎不仅仅是开发者“装x”的工具，它可以让开发人者清理自己的代码，进而理清自己的思路。所以不应低估简洁和声明性代码提高的可读性，开发效率和模块化且可维护的应用程序的重要性。在AI代替人类编程之前，我们必须遵循这些可以让打击都清楚理解的约束，这样才有助于项目壮大。","categories":[],"tags":[{"name":"Serverless, Azure, Azure Function","slug":"Serverless-Azure-Azure-Function","permalink":"http://yesihao.com/tags/Serverless-Azure-Azure-Function/"}]},{"title":"如何使用VS Code快速部署Azure Function","slug":"Azure Function Part II","date":"2020-05-05T13:15:33.000Z","updated":"2020-05-09T07:22:03.504Z","comments":true,"path":"2020/05/05/Azure Function Part II/","link":"","permalink":"http://yesihao.com/2020/05/05/Azure%20Function%20Part%20II/","excerpt":"","text":"前言本文将介绍部署Azure Function的完整过程。这一次会使用Node.js作为开发语言，以及使用VS Code作为编辑器。![如何使用VS Code如何快速部署Azure Function-1](/images/如何使用VS Code如何快速部署Azure Function-1.jpg) 在后面的博文中会写到如何提高Node.js Azure functions的性能。 进入正题首先在Azure portal上创建一个Function App然后选择使用VS Code做为开发环境。 我们先了解一些基本参数： App name：functions群组的唯一名称。这也是资源最终URL的尾部。比如App name是example，URL就会是example.azurewebsites.net Subscription: 选择你的订阅 Resource group &amp; version: 选择开发语言和版本 OS: Windows是默认的选项，但是你也可以使用Linux Runtime stack: 我们选择node，版本选择10 Publish: 发布类型，我们选择code Hosting plan: 现在一个消费计划，Azure Fuctions计费已次计算，很便宜。具体参考Azure functions定价 Location: 选择一个资源的位置，中国速度最快应该是东亚地区 Application Insights: 用于记录日志定位问题 点击创建过几分钟之后，会提示创建成功。 然后我们选择VS Code作为开发环境 提示我们需要安装所需工具，在上一篇博文中，我们介绍安装了开发Azure Functions的工具。这里不再赘述。 我们推荐在VS Code中安装两个扩展： Azure Account: 整合Azure账户和VS Code. Azure Functions: 帮助我们创建，维护，管理，部署function 下一步我们登录的我们的Azure账号，然后我们就可以看到我们刚刚建立的Function App 现在可以使用Azure Functions扩展床一个HTTP trigger的function 然后输入Function名称，选择‘Function’作为缱绻等级 现在我们已经创建了一个function。主文件是index.js。这是一个模版，它接受一个get或post请求，在参数中如果有name字段，则返回“Hello ” + (req.query.name || req.body.name)，否则返回400错误. 另外一个重要的文件是function.json，它包含了一些配置。比较常用的配置是HTTP请求方式。你可以选择GET, POST, PUT, DELETE, OPTIONS等。 测试你的Function然后部署到Azure本地运行之后，我们可以断点进行调试。 接下来我们要部署到这个function，选中function名称，右键，选择“Deploy to Function App…” 选择你想部署到的Fnction App 如果没有问题，我们可以收到一个部署成功的提示 总结使用VS Code开发是非常高效的，它集合Azure官方的扩展，所以很容易地本地开发和部署到Azure。","categories":[],"tags":[{"name":"Serverless, Azure, Azure Function, VS Code","slug":"Serverless-Azure-Azure-Function-VS-Code","permalink":"http://yesihao.com/tags/Serverless-Azure-Azure-Function-VS-Code/"}]},{"title":"Azure Functions - 配置开发环境","slug":"Azure Function Part I","date":"2020-03-29T12:55:10.000Z","updated":"2020-04-08T01:50:42.196Z","comments":true,"path":"2020/03/29/Azure Function Part I/","link":"","permalink":"http://yesihao.com/2020/03/29/Azure%20Function%20Part%20I/","excerpt":"","text":"前言说Azure functions之前先来说说Serverless。Serverless是最近很火的一个概念，它是一种基于互联网的技术架构理念，应用逻辑并非全部在服务端实现，而是采用FAAS（Function as a Service）架构，通过功能组合来实现应用程序逻辑。应用业务逻辑将基于FAAS架构形成独立为多个相互独立功能组件，并以API服务的形式向外提供服务；很多公司都在自己的云平台推出了FAAS，比如Amazon Lambda，Azure Function，Google Cloud Functions，阿里云Function Compute等。 微软的Azure functions是基于Azure的无服务器计算服务，可以快速的帮助用户构建一个基于事件驱动的应用架构。用户无需关心服务器的部署运营，只需专注于核心的逻辑，既可以发布上线。费用按照实际调用次数与时长计费，自动缩放，仅在运行函数时为计算资源付费。更棒的是Azure Functions支持C#，Python，Javascript，TypeScript，F#和Java，本文带大家快速看在本地搭建Javascript开发环境开发Azure Functions。 环境安裝可以使用Visual Studio Code和Visual Studio开发，本文将会使用的VS Code。 首先在扩展市场中搜索Azure functions，你也可以直接安裝Azure App Service，这样你就拥有所有相关扩展服务，也可以仅安裝Azure Functions。 ![Azure Function扩展](/images/Azure Function Ext.jpg) 接著，我们要安裝 Azure Function Core Tools，在命令行安装： 12345678910#via npmnpm i -g azure-functions-core-tools --unsafe-perm true#Linuxwget -q https://packages.microsoft.com/config/ubuntu/19.04/packages-microsoft-prod.debsudo dpkg -i packages-microsoft-prod.deb#Macbrew tap azure/functionsbrew install azure-functions-core-tools 或者我们可以点击Debug | Run, VS Code会自动提示安装Azure Function Core Tools，确定后自动执行上方命令。 ![Azure Function Core Tools 自动安装](/images/Azure Function Debug1.jpg) 安裝成功之后，我们可以在命令行输入 func 来检查是否安装成功。 ![Azure Function Core Tools 安装成功](/images/Azure Function Core Tools.jpg) 出现 闪电 就说明安装成功了！ ##预告 下一篇博文将会讲到 如何快速部署Azure Function","categories":[],"tags":[{"name":"Serverless, Azure, Azure Function","slug":"Serverless-Azure-Azure-Function","permalink":"http://yesihao.com/tags/Serverless-Azure-Azure-Function/"}]},{"title":"Javascript - 排序排序的小技巧","slug":"Javascript - 排序排序的小技巧","date":"2020-02-28T11:34:40.000Z","updated":"2020-04-01T04:57:55.188Z","comments":true,"path":"2020/02/28/Javascript - 排序排序的小技巧/","link":"","permalink":"http://yesihao.com/2020/02/28/Javascript%20-%20%E6%8E%92%E5%BA%8F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"","text":"普通数组:1let fruits = [`bananas`, `Apples`, `Oranges`]; 很简单，一行搞定： 1fruits.sort(); 但是要注意数组中不同字符串的大小写不一致… 大写的字符会被排在小写字符之前😂所以还有其他的步骤： 1234567let fruits = [`bananas`, `Apples`, `Oranges`];fruits.sort((a, b) =&gt; &#123; return a.toLowerCase().localeCompare(b.toLowerCase());&#125;)console.log(fruits);// [&quot;Apples&quot;, &quot;bananas&quot;, &quot;Oranges&quot;] 对象数组（按对象键值排序）对对象数组的排序会变得很稍微更复杂一些。经常我们会在处理JSON API的时候遇到。 1234567891011let fruits = [ &#123; fruit: `Bananas` &#125;, &#123; fruit: `apples` &#125;, &#123; fruit: `Oranges` &#125;]; 我们可以为此写一个排序函数，但是更进一步我们需要一个更通用的方法把需要排序的键以参数的形式传进去 1234567891011121314const propComparator = (propName) =&gt; (a, b) =&gt; a[propName].toLowerCase() == b[propName].toLowerCase() ? 0 : a[propName].toLowerCase() &lt; b[propName].toLowerCase() ? -1 : 1So now we can use it to sort:fruits.sort(propComparator(`fruit`));console.log(fruits);/*[ &#123;fruit: &quot;apples&quot;&#125;, &#123;fruit: &quot;Bananas&quot;&#125;, &#123;fruit: &quot;Oranges&quot;&#125;]*/ 普通对象如果我们有个对象是这样的： 12345let fruits = &#123; Bananas: true, apples: false, Oranges: true&#125;; 我们依然可以将那些键小写化，然后我们先排序键的数组，然后用排序好的键数组建一个新对象 123456789101112131415let sortedFruits = &#123;&#125;;Object.keys(fruits).sort((a, b) =&gt; &#123; return a.toLowerCase().localeCompare(b.toLowerCase());&#125;).forEach(function(key) &#123; sortedFruits[key] = fruits[key];&#125;);console.log(sortedFruits);/*&#123; apples: false, Bananas: true, Oranges: true&#125;*/ 对象数组（按对象键排序）1234567891011let fruits = [ &#123; Bananas: true &#125;, &#123; Apples: false &#125;, &#123; oranges: true &#125;]; 可能这是上述情况中最复杂，但是结合所有的方法，其实也很简单🐶","categories":[],"tags":[{"name":"Javascript, array","slug":"Javascript-array","permalink":"http://yesihao.com/tags/Javascript-array/"}]}]}